<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.20" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme='dark'] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background-color: var(--vp-c-bg);
      }
    </style>
    <script>
      const useChoice = localStorage.getItem('vuepress-color-scheme')
      const systemStatus =
        'matchMedia' in window
          ? window.matchMedia('(prefers-color-scheme: dark)').matches
          : false

      if (useChoice === 'light') {
        document.documentElement.dataset.theme = 'light'
      } else if (useChoice === 'dark' || systemStatus) {
        document.documentElement.dataset.theme = 'dark'
      }
    </script>
    <title>Docker | 彼岸樱速</title><meta name="description" content="欢迎来到bays的笔记文档空间">
    <link rel="stylesheet" href="/assets/css/styles.c66d6f1b.css">
    <link rel="preload" href="/assets/js/runtime~app.0d688386.js" as="script"><link rel="preload" href="/assets/css/styles.c66d6f1b.css" as="style"><link rel="preload" href="/assets/js/80.d657ec11.js" as="script"><link rel="preload" href="/assets/js/app.52dbea86.js" as="script">
    <link rel="prefetch" href="/assets/js/guide_docker.html.1be59d85.js" as="script"><link rel="prefetch" href="/assets/js/guide_activeMQ.html.70fea2e2.js" as="script"><link rel="prefetch" href="/assets/js/guide_awt.html.1bfb567f.js" as="script"><link rel="prefetch" href="/assets/js/guide_Arthas.html.c153b8fb.js" as="script"><link rel="prefetch" href="/assets/js/get-started.html.b5dc71a3.js" as="script"><link rel="prefetch" href="/assets/js/index.html.7a4fbc54.js" as="script"><link rel="prefetch" href="/assets/js/posts_sticky2.html.d9cac4c3.js" as="script"><link rel="prefetch" href="/assets/js/posts_archive2.html.f68e76d4.js" as="script"><link rel="prefetch" href="/assets/js/posts_archive1.html.4f0cf356.js" as="script"><link rel="prefetch" href="/assets/js/posts_article11.html.06296013.js" as="script"><link rel="prefetch" href="/assets/js/posts_article12.html.1d8d1792.js" as="script"><link rel="prefetch" href="/assets/js/posts_article10.html.5c0b3ffa.js" as="script"><link rel="prefetch" href="/assets/js/posts_article4.html.47354b73.js" as="script"><link rel="prefetch" href="/assets/js/posts_article5.html.c37516dd.js" as="script"><link rel="prefetch" href="/assets/js/posts_article6.html.93dd44a9.js" as="script"><link rel="prefetch" href="/assets/js/posts_article7.html.dcc4666e.js" as="script"><link rel="prefetch" href="/assets/js/posts_article8.html.1eb7469d.js" as="script"><link rel="prefetch" href="/assets/js/posts_article9.html.c42c4aee.js" as="script"><link rel="prefetch" href="/assets/js/posts_article3.html.39ed2ef6.js" as="script"><link rel="prefetch" href="/assets/js/posts_article1.html.4e814018.js" as="script"><link rel="prefetch" href="/assets/js/posts_article2.html.d024ac22.js" as="script"><link rel="prefetch" href="/assets/js/posts_sticky.html.3680f02b.js" as="script"><link rel="prefetch" href="/assets/js/category_category-a_index.html.52607d9f.js" as="script"><link rel="prefetch" href="/assets/js/category_category-c_index.html.512fe185.js" as="script"><link rel="prefetch" href="/assets/js/category_category-b_index.html.082a49aa.js" as="script"><link rel="prefetch" href="/assets/js/category_history_index.html.8d52ff6c.js" as="script"><link rel="prefetch" href="/assets/js/tag_tag-a_index.html.c9fbdcde.js" as="script"><link rel="prefetch" href="/assets/js/tag_tag-b_index.html.efaa4391.js" as="script"><link rel="prefetch" href="/assets/js/tag_tag-d_index.html.94a14403.js" as="script"><link rel="prefetch" href="/assets/js/tag_tag-e_index.html.848c629f.js" as="script"><link rel="prefetch" href="/assets/js/tag_tag-c_index.html.d71f5d38.js" as="script"><link rel="prefetch" href="/assets/js/category_index.html.2476444c.js" as="script"><link rel="prefetch" href="/assets/js/tag_wwii_index.html.616f6e69.js" as="script"><link rel="prefetch" href="/assets/js/tag_wwi_index.html.a7384146.js" as="script"><link rel="prefetch" href="/assets/js/404.html.73372f67.js" as="script"><link rel="prefetch" href="/assets/js/timeline_index.html.5206e93a.js" as="script"><link rel="prefetch" href="/assets/js/article_index.html.12dee35a.js" as="script"><link rel="prefetch" href="/assets/js/tag_index.html.507c41b2.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container external-link-icon" vp-container><!--[--><header class="vp-navbar" vp-navbar><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/"><img class="vp-site-logo" src="/logo.png" alt="彼岸樱速"><span class="vp-site-name vp-hide-mobile" aria-hidden="true">彼岸樱速</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/" aria-label="Home"><!--[--><!--[--><!--]--><!--]-->Home<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="auto-link external-link" href="https://bianyingsu.github.io" aria-label="梦起" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->梦起<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/guide/activeMQ.html" aria-label="activeMQ"><!--[--><!--[--><!--]--><!--]-->activeMQ<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/article/" aria-label="Article"><!--[--><!--[--><!--]--><!--]-->Article<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/category/" aria-label="Category"><!--[--><!--[--><!--]--><!--]-->Category<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/tag/" aria-label="Tag"><!--[--><!--[--><!--]--><!--]-->Tag<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/timeline/" aria-label="Timeline"><!--[--><!--[--><!--]--><!--]-->Timeline<!--[--><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button type="button" class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar" vp-sidebar><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/" aria-label="Home"><!--[--><!--[--><!--]--><!--]-->Home<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="auto-link external-link" href="https://bianyingsu.github.io" aria-label="梦起" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->梦起<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/guide/activeMQ.html" aria-label="activeMQ"><!--[--><!--[--><!--]--><!--]-->activeMQ<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/article/" aria-label="Article"><!--[--><!--[--><!--]--><!--]-->Article<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/category/" aria-label="Category"><!--[--><!--[--><!--]--><!--]-->Category<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/tag/" aria-label="Tag"><!--[--><!--[--><!--]--><!--]-->Tag<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/timeline/" aria-label="Timeline"><!--[--><!--[--><!--]--><!--]-->Timeline<!--[--><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><a class="route-link auto-link vp-sidebar-item vp-sidebar-heading" href="/guide/activeMQ.html" aria-label="ActiveMQ"><!--[--><!--[--><!--]--><!--]-->ActiveMQ<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item vp-sidebar-heading" href="/guide/Arthas.html" aria-label="Arthas"><!--[--><!--[--><!--]--><!--]-->Arthas<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item vp-sidebar-heading" href="/guide/awt.html" aria-label="AWT &amp;&amp; Swing"><!--[--><!--[--><!--]--><!--]-->AWT &amp;&amp; Swing<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link route-link-active auto-link vp-sidebar-item vp-sidebar-heading active" href="/guide/docker.html" aria-label="Docker"><!--[--><!--[--><!--]--><!--]-->Docker<!--[--><!--[--><!--]--><!--]--></a><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div vp-content><!--[--><!--]--><div><h1 id="docker" tabindex="-1"><a class="header-anchor" href="#docker"><span>Docker</span></a></h1><hr><p>aliases:</p><ul><li>docker 标题: docker</li></ul><hr><p><strong>docker compose是什么</strong></p><p><strong>笔记本：</strong> docker</p><p><strong>创建时间：</strong> 2023/12/11 14:37 <strong>更新时间：</strong> 2024/5/20 17:41</p><h2 id="docker-compose是什么" tabindex="-1"><a class="header-anchor" href="#docker-compose是什么"><span><strong>docker compose是什么</strong></span></a></h2><p>docker compose是一个命令行工具，是用于定义和运行多容器Docker应用程序的工</p><p>具；通过Compose，开发者可以使用YML文件来配置应用程序需要的所有服务。</p><img src="/img/docker.pdf-0-0.png"><p>本教程操作环境：linux5.9.8系统、docker-1.13.1版、Dell G3电脑。</p><p><strong>docker Compose 简介</strong></p><p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用</p><p>YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中</p><p>创建并启动所有服务。</p><p>Compose 使用的三个步骤：</p><ol><li><p>使用 Dockerfile 定义应用程序的环境。</p></li><li><p>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</p></li><li><p>最后，执行 docker-compose up 命令来启动并运行整个应用程序。</p></li></ol><p><strong>Compose 安装</strong></p><p>Linux 上我们可以从 Github 上下载它的二进制包来使用，最新发行的版本地址：</p><p>https://github.com/docker/compose/releases。</p><p>运行以下命令以下载 Docker Compose 的当前稳定版本：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">$ sudo curl -L &quot;https://github.com/docker/compose/releases/download/v2.2.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>要安装其他版本的 Compose，请替换 1.24.1。</p><p>将可执行权限应用于二进制文件：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">$ sudo chmod +x /usr/local/bin/docker-compose</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>创建软链：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">$ sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>测试是否安装成功：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">$ docker-compose --version</span>
<span class="line">cker-compose version 1.24.1, build 4667896b</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>注意： 对于 alpine，需要以下依赖包： py-pip，python-dev，libffi-dev，openssl-dev，gcc，</p><p>libc-dev，和 make。</p><p><strong>「Docker」与「k8s」的区别</strong></p><p><strong>笔记本：</strong> docker</p><p><strong>创建时间：</strong> 2024/5/20 16:53 <strong>更新时间：</strong> 2024/5/20 17:00</p><h2 id="「docker」与「k8s」的区别" tabindex="-1"><a class="header-anchor" href="#「docker」与「k8s」的区别"><span><strong>「Docker」与「k8s」的区别</strong></span></a></h2><p>随着 k8s 作为容器编排解决方案变得越来越流行，有些人开始拿 Docker 和 k8s 进行对比，</p><p>不禁问道：Docker不香吗？</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">k8s 是 kubernetes 的缩写，&#39;8&#39; 代表中间的八个字符。</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>其实 Docker 和 k8s 并非直接的竞争对手，它俩相互依存。 Docker 是一个容器化平台，而 k8s 是Docker 等容器平台的协调器。</p><h5 id="_1-容器化时代来了" tabindex="-1"><a class="header-anchor" href="#_1-容器化时代来了"><span># 1. 容器化时代来了</span></a></h5><p>虚拟化技术已经走过了三个时代，没有容器化技术的演进就不会有 Docker 技术的诞生。</p><img src="/img/docker.pdf-2-0.png"><p>（1） <strong>物理机时代</strong> ：多个应用程序可能会跑在一台机器上。</p><img src="/img/docker.pdf-2-1.png"><p>（2） <strong>虚拟机时代</strong> ：一台物理机器安装多个虚拟机（VM），一个虚拟机跑多个程序。</p><img src="/img/docker.pdf-2-2.png"><p>（3） <strong>容器化时代</strong> ：一台物理机安装多个容器实例（container），一个容器跑多个程序。</p><img src="/img/docker.pdf-3-0.png"><p>容器化解决了软件开发过程中一个令人非常头疼的问题，用一段对话描述：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">测试人员：你这个功能有问题。</span>
<span class="line">开发人员：我 **本地** 是好的呀！</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>开发人员编写代码，在自己本地环境测试完成后，将代码部署到测试或生产环境中，经常会遇到各种</p><p>各样的问题。明明本地完美运行的代码为什么部署后出现很多 bug，原因有很多： <strong>不同的操作系统、</strong></p><p><strong>不同的依赖库等，总结一句话就是因为本地环境和远程环境不一致</strong> 。</p><p><strong>容器化技术正好解决了这一关键问题，它将软件程序和运行的基础环境分开。开发人员编码完成后将</strong></p><p><strong>程序打包到一个容器镜像中，镜像中详细列出了所依赖的环境，在不同的容器中运行标准化的镜像，</strong></p><p><strong>从根本上解决了环境不一致的问题。</strong></p><p>⭐虽然容器概念已经出现不短的时间，但 2013 年推出的开源项目 Docker 在很大程度上帮助推广了</p><p>容器这项技术，并推动了软件开发中 <strong>容器化</strong> 和 <strong>微服务</strong> 的趋势， <strong>这种趋势后来被称为云原生开发</strong> 。</p><h5 id="_2-容器化技术的尖刀武器" tabindex="-1"><a class="header-anchor" href="#_2-容器化技术的尖刀武器"><span># 2. 容器化技术的尖刀武器</span></a></h5><img src="/img/docker.pdf-3-1.png"><ul><li><p><strong>可移植性</strong> ：不依赖具体的操作系统或云平台，比如在阿里云或腾讯云直接随意迁移。</p></li><li><p><strong>占地小</strong> ：容器只需要其应用程序以及它需要运行的所有容器和库的依赖清单，不需要将所有的依</p></li></ul><p>赖库都打包在一起。</p><ul><li><strong>共享 bin 和 lib</strong> ：不同的容器可以共享 bin 和 lib，进一步节省了空间。</li></ul><h5 id="_3-docker-横空出世" tabindex="-1"><a class="header-anchor" href="#_3-docker-横空出世"><span># 3. Docker 横空出世</span></a></h5><p>2010 年一位年轻小伙子在美国旧金山成立了一家名叫【dotCloud】的公司， 开发了 Docker 的核心技术，从此开启了容器技术的时代。</p><img src="/img/docker.pdf-4-0.png"><p>后面 dotCloud 公司将自己的容器技术进行了简化和标准化，取名为 Docker，就是大家熟悉的鲸鱼logo。</p><img src="/img/docker.pdf-4-1.png"><p>2013 年 dotCloud 公司宣布将 Docker 开源，随着越来越多的工程师发现了它的优点， Docker 的人气迅速攀升，成为当时最火爆的开源技术之一。</p><p>当前有 30％ 以上的企业在其 AWS 环境中使用 Docker，并且这个数字还在继续增长。</p><img src="/img/docker.pdf-5-0.png"><p>此时的 Docker，已经成为行业里人气最火爆的开源技术，没有之一。甚至像 Google、微软、Amazon、VMware 这样的巨头，都对它青睐有加，表示将全力支持。</p><p>Docker 火了之后，dotCloud 公司干脆把公司名字也改成了 Docker Inc.。</p><p>Docker 和容器技术为什么会这么火爆？说白了，就是因为它 “ <strong>轻</strong> ”。</p><p>在容器技术之前，业界的网红是 <strong>虚拟机</strong> 。虚拟机技术的代表，是 <strong>VMWare</strong> 和 <strong>OpenStack</strong> 。</p><img src="/img/docker.pdf-5-1.png"><p>相信很多人都用过虚拟机。虚拟机，就是在你的操作系统里面，装一个软件，然后通过这个软件，再</p><p>模拟一台甚至多台“子电脑”出来。</p><img src="/img/docker.pdf-6-0.png"><p>在 “子电脑” 里，你可以和正常电脑一样运行程序，例如登录 QQ。如果你愿意，你可以变出好几个</p><p>“子电脑”，里面都登录上 QQ。“子电脑” 和 “子电脑” 之间，是 <strong>相互隔离</strong> 的，互不影响。</p><p>虚拟机属于虚拟化技术。而 Docker 这样的容器技术，也是虚拟化技术，属于 <strong>轻量级的虚拟化</strong> 。</p><p>虚拟机虽然可以隔离出很多 “子电脑”，但占用空间更大，启动更慢，虚拟机软件可能还要花钱（例如：VMWare）。</p><p>而容器技术恰好没有这些缺点。它不需要虚拟出整个操作系统，只需要虚拟一个小规模的环境（类似“ <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F678d8836cdbd" target="_blank" rel="noopener noreferrer">⇲</a> 沙箱”）。Docker 可以轻松创建容器和基于容器的应用程序， <strong>最初是为 Linux 构建的</strong> ，现在也可以在 Windows 和 MacOS 上运行。</p><p>它启动时间很快，几秒钟就能完成。而且，它对资源的利用率很高（一台主机可以同时运行几千个Docker 容器）。此外，它占的空间很小，虚拟机一般要几 GB 到几十 GB 的空间，而容器只需要 MB级甚至 KB 级。</p><img src="/img/docker.pdf-6-1.png"><p>正因为如此，容器技术受到了热烈的欢迎和追捧，发展迅速。大家需要注意， <strong>Docker 本身并不是容器</strong> ，它是创建容器的工具，是应用容器引擎。想要搞懂 Docker，其实看它的两句口号就行。</p><p>第一句，是 <strong>“Build, Ship and Run”</strong> 。</p><p>第二句口号则是： <strong>“Build once，Run anywhere（搭建一次，到处能用）”。</strong></p><img src="/img/docker.pdf-7-0.png"><ul><li><p><strong>Build（构建镜像）</strong> ： 镜像就像是集装箱，包含文件以及运行环境等等资源；</p></li><li><p><strong>Ship（运输镜像）</strong> ：在 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fcloud.tencent.com%2Fproduct%2Fcdh%3Ffrom%3D10680" target="_blank" rel="noopener noreferrer">⇲</a> 宿主机和仓库间进行运输，这里仓库就像是超级码头；</p></li><li><p><strong>Run（运行镜像）</strong> ：运行的镜像就是一个容器，容器就是运行程序的地方。</p></li></ul><p>⭐说白了，这个 Docker 镜像，是一个特殊的文件系统。它除了提供容器运行时所需的程序、库、资</p><p>源、配置等文件外，还包含了一些为运行时准备的一些配置参数（例如：环境变量）。 <strong>镜像不包含任何动态数据，其内容在构建之后也不会被改变</strong> 。</p><p>⭐综上所述，Docker 的运行过程，也就是去仓库把镜像拉到本地，然后用执行命令把镜像运行起来</p><p>变成容器，这也就是为什么人们常常将 Docker 称为码头工人或码头装卸工。</p><p>⭐负责对 Docker 镜像进行管理的，是 <strong>Docker Registry 服务</strong> （类似仓库管理员）。当然，不是任何人建的任何镜像都是合法的。万一有人构建的镜像存在问题呢？所以，Docker Registry 服务对镜像的管理是非常严格的。最常使用的 Registry 公开服务，是官方的 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fhub.docker.com%2F" target="_blank" rel="noopener noreferrer">⇲</a> Docker Hub，这也是默认的Registry，并拥有大量的高质量的官方镜像。</p><h5 id="_4-docker-如何使用" tabindex="-1"><a class="header-anchor" href="#_4-docker-如何使用"><span># 4. Docker 如何使用</span></a></h5><p>其实大多数人谈论 Docker 时说的是 <strong>Docker Engine</strong> ，这只是一个构建和运行的容器。</p><p>在运行容器前需要编写 Docker File，通过 <strong>dockerFile</strong> 生成镜像，然后才能运行 Docker 容器。</p><p>Docker File 定义了运行镜像（ <strong>image</strong> ）所需的所有内容，包括操作系统和软件安装位置。一般情况下</p><p>都不需要从头开始编写 Docker File，在 Docker Hub 中有来自世界各地的工程师编写好的镜像，你</p><p>可以基于此修改。</p><p>此外，Docker 容器提供了一种构建企业应用程序和业务流程应用程序的方法，这些应用程序比传统应</p><p>用程序更容易安装、维护和移动。</p><p>⭐Docker 容器支持 <strong>隔离</strong> ：Docker 容器使应用程序不仅彼此隔离，而且与底层系统隔离。这不仅使软</p><p>件栈更干净，而且更容易使容器化应用程序使用系统资源，例如 <strong>CPU、GPU、内存、I/O、网络</strong> 等，</p><p>它还可以 <strong>确保数据和代码保持独立</strong> 。</p><p>⭐Docker 容器支持 <strong>可移植性</strong> ：Docker 容器在支持容器运行环境的任何机器上运行。应用程序不必绑</p><p>定到主机操作系统，因此可以保持应用程序环境和底层操作环境的整洁和最小化。</p><p>例如，采用容器的 MySQL 将在大多数支持容器的 Linux 系统上运行，应用程序的所有依赖项通常都</p><p>在同一个容器中提供。基于容器的应用程序可以轻易从 on-prem 系统迁移到云环境中，或从开发人员</p><p>的笔记本电脑移到服务器上，只要目标系统支持 Docker 以及可能与之一起使用的任何第三方工具，</p><p>比如 Kubernetes。</p><p>⭐通常，Docker 容器镜像必须为特定的平台构建。例如 Windows 容器不能在 Linux 上运行，反之</p><p>亦然；以前，绕过此限制的一种方法是启动运行所需操作系统实例的虚拟机，并在虚拟机中运行容</p><p>器。</p><p>然而 Docker 团队后来设计了一个更优雅的解决方案，称为 <strong>manifest</strong> ，它允许多个操作系统的镜像并</p><p>行打包。尽管 manifest 还处于试验阶段，但这暗示了容器可能成为跨平台应用程序解决方案和跨环境</p><p>应用程序解决方案。</p><p>⭐Docker 容器支持 <strong>可组合性</strong> ：大多数业务应用程序由几个独立的组件组成，web 服务器、数据库和</p><p>cache 缓存。 <strong>Docker 容器可以将这些部件组合成一个容易更换的功能单元。每个部分由不同的容器</strong></p><p><strong>提供，可以独立于其他容器进行维护、更新、交换和修改。</strong></p><p>这本质上是应用程序设计的 <strong>微服务模型</strong> 。通过将应用程序功能划分为独立的、自包含的服务，微服务</p><p>模型为过程缓慢的传统开发和单一僵化的应用程序提供了一种解决方案，轻量级和便携式容器使构建</p><p>和维护基于微服务的应用程序变得更加容易。</p><h5 id="_5-编排系统的需求催生-k8s" tabindex="-1"><a class="header-anchor" href="#_5-编排系统的需求催生-k8s"><span># 5. 编排系统的需求催生 k8s</span></a></h5><p>尽管 Docker 为容器化的应用程序提供了开放标准，但随着容器越来越多出现了一系列新问题：</p><ul><li><p>如何 <strong>协调、调度和管理</strong> 这些容器？</p></li><li><p>如何在升级应用程序时 <strong>不中断服务</strong> ？</p></li><li><p>如何 <strong>监视</strong> 应用程序的运行状况？</p></li><li><p>如何批量重新启动容器里的程序？</p></li></ul><p>解决这些问题需要容器编排技术，可以将众多机器抽象，对外呈现出一台超大机器。现在业界比较流</p><p>行的有： <strong>k8s</strong> 、Mesos、 <strong>Docker Swarm</strong> 。</p><p>在业务发展初期只有几个微服务，这时用 Docker 就足够了，但随着业务规模逐渐扩大，容器越来越</p><p>多，运维人员的工作越来越复杂，这个时候就需要编排系统解救 opers。</p><img src="/img/docker.pdf-8-0.png"><p>一个成熟的容器编排系统需要具备以下能力：</p><ul><li><p>处理大量的容器和用户</p></li><li><p>负载均衡</p></li><li><p>鉴权和安全性</p></li><li><p>管理服务通信</p></li><li><p>多平台部署</p></li></ul><p><strong>其中，K8S，就是基于容器的集群管理平台，它的全称，是 kubernetes。</strong></p><img src="/img/docker.pdf-9-0.png"><p>和 Docker 不同，K8S 的创造者，是众人皆知的行业巨头—— <strong>Google</strong> 。</p><p>然而，K8S 并不是一件全新的发明。它的前身，是 Google 自己捣鼓了十多年的 <strong>Borg 系统</strong> 。K8S 是Google 研发的容器协调器，已捐赠给 CNCF，现已开源。</p><p>Google 利用在容器管理多年的经验和专业知识推出了 k8s，主要用于 <strong>自动化部署应用程序容器</strong> ，可以</p><p>支持众多容器化工具包括现在非常流行的 Docker。</p><p>目前 k8s 是容器编排市场的领导者，开源并公布了一系列标准化方法，主流的公有云平台都宣布支持。</p><p>一流的厂商都在抢占标准的制高点，一堆小厂商跟着一起玩，这就叫 <strong>生态</strong> 了。国内的大厂商都在干嘛呢？抢社区团购市场，玩资本游戏，哎？！</p><h5 id="_6-k8s-架构和组件" tabindex="-1"><a class="header-anchor" href="#_6-k8s-架构和组件"><span># 6. k8s 架构和组件</span></a></h5><p>k8s 由众多组件组成，组件间通过 API 互相通信，归纳起来主要分为三个部分：</p><ul><li><p>controller manager</p></li><li><p>nodes</p></li><li><p>pods</p></li></ul><p><strong>k8s 集群架构图</strong> ：</p><img src="/img/docker.pdf-10-0.png"><ul><li><p><strong>Controller Manager</strong> ，即控制平面，用于 <strong>调度</strong> 程序以及节点状态 <strong>检测</strong> 。</p></li><li><p><strong>Nodes</strong> ，构成了 Kubernetes 集群的集体计算能力， <strong>实际部署容器运行的地方</strong> 。</p></li><li><p><strong>Pods</strong> ，Kubernetes 集群中 <strong>资源的最小单位</strong> 。</p></li></ul><p>下图是 <strong>Kubernetes 集成 Jenkins 实现 CICD</strong> （一图胜千言，需要对其有一个大致的认识）：</p><img src="/img/docker.pdf-10-1.png"><p>而下图则是 <strong>GitLab + Jenkins Pipeline + Doker + k8s + Helm 自动化部署</strong> ：</p><img src="/img/docker.pdf-11-0.png"><h5 id="_7-k8s-与-docker-swarm-江湖恩怨" tabindex="-1"><a class="header-anchor" href="#_7-k8s-与-docker-swarm-江湖恩怨"><span># 7. k8s 与 Docker Swarm 江湖恩怨</span></a></h5><p><strong>Docker Swarm</strong> 与 <strong>k8s</strong> 同为容器编排技术。</p><img src="/img/docker.pdf-11-1.png"><p>如果你非要拿 Docker 和 k8s 进行比较，其实你更应该拿 <strong>Docker Swarm</strong> 和 <strong>k8s</strong> 比较。</p><p>Docker Swarm 是 Docker 自家针对集群化部署管理的解决方案，优点很明显，可以更紧密集成到</p><p>Docker 生态系统中。</p><p>虽说 Swarm 是 Docker 亲儿子，但依旧没有 k8s 流行，不流行很大程度是因为商业、生态的原因，</p><p>不多解释。</p><h5 id="_8-docker-与-k8s-难舍难分" tabindex="-1"><a class="header-anchor" href="#_8-docker-与-k8s-难舍难分"><span># 8. Docker 与 k8s 难舍难分</span></a></h5><p>Docker 和 k8s 在业界非常流行，都已经是事实上的标准。</p><p>Docker 是用于构建、分发、运行（Build, Ship and Run）容器的平台和工具。</p><p>而 k8s 实际上是一个使用 Docker 容器进行编排的系统，主要围绕 pods 进行工作。 <strong>Pods 是 k8s 生</strong></p><p><strong>态中最小的调度单位，可以包含一个或多个容器。</strong></p><p>Docker 和 k8s 是根本上不同的技术，两者可以很好的协同工作。</p><h5 id="_9-开发实践-灵魂追问" tabindex="-1"><a class="header-anchor" href="#_9-开发实践-灵魂追问"><span># 9. 开发实践，灵魂追问</span></a></h5><p>（1） <strong>为什么还要用 k8s？没有 k8s 可以使用 docker 吗？</strong></p><p>可以。实际上一些小型公司，在业务不太复杂的情况下都是直接使用 Docker。尽管 k8s 有很多好</p><p>处，但是众所周知它非常复杂，业务比较简单可以放弃使用 k8s。但 k8s 在业务达到一定规模后也得</p><p>启用！</p><p>（2） <strong>没有 Docker 可以使用 k8s 吗？</strong></p><p>k8s 只是一个容器编排器，没有容器拿什么编排？！</p><p>k8s 经常与 Docker 进行搭配使用，但是也可以使用其他容器，如 RunC、Containerted 等。</p><p>（3） <strong>Docker Swarm 和 k8s 怎么选？</strong></p><p>选 k8s。2019 年底 Docker Enterprise 已经出售给 Mirantis，Mirantis 声明要逐步淘汰 DockerSwarm，后续会将 k8s 作为默认编排工具。</p><p><strong>Docker /var/lib/docker/overlay2占用100%</strong></p><p><strong>笔记本：</strong> docker</p><p><strong>创建时间：</strong> 2024/4/2 23:36 <strong>更新时间：</strong> 2024/4/2 23:40</p><h4 id="docker-var-lib-docker-overlay2占用100" tabindex="-1"><a class="header-anchor" href="#docker-var-lib-docker-overlay2占用100"><span><strong>Docker /var/lib/docker/overlay2占用100%</strong></span></a></h4><p>本文解决方案：</p><p>出现问题</p><p>找到问题</p><p>解决问题</p><p>防止以后问题复现</p><p>今天很纳闷，打算上去看一下自己的小破站，结果上不去了，吓得我赶快登上服务器看一</p><p>下，结果是容器日志占用满了</p><img src="/img/docker.pdf-13-0.png"><p>起初我还被这个“/var/lib/docker/overlay2/”路径给迷糊住了，一度认为是“overlay2”文件夹</p><p>内的日志把磁盘占用100%了，后来进去之后发现该文件夹占用也才5GB，遂开始了头疼掉头发</p><p>既然我已经知道是docker的问题了，这个时候就应该从docker目录开始查，在</p><p>“/var/lib/docker”目录下使用命令“du -h --max-depth=1”，ps：--max-depth=1意思为检索</p><p>文件的最大深度1，即只检索汇总计算当前目录下的文件</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">du -h --max-depth=1</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><img src="/img/docker.pdf-13-2.png"><p>从图中可以看出虽然提示的是“/var/lib/docker/containers”目录磁盘占用34G，而</p><p>“overlay2”目录磁盘占用只有5G左右，所以小伙伴们不要被“/var/lib/docker/overlay2/”磁盘占用100%给骗了而 一时乱了手脚</p><p>这个时候我们进入“/var/lib/docker/containers”目录看看究竟是哪个容器沾满了咱们的磁</p><p>盘，进入“containers”目录后我们继续使用“du -h --max-depth=1”命令查看哪个目录占用</p><p>磁盘大，ps：docker ps命令中的容器ID是从“containers”目录中的文件夹名称头进行截取的，进行比对遂能查看出来是哪个容器占满了磁盘</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">du -h --max-depth=1</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><img src="/img/docker.pdf-14-0.png"><img src="/img/docker.pdf-14-1.png"><p>从这里咱们能够看出来占了咱们32G磁盘容量的就是redis容器了，这个时候咱们进去占用了32G磁盘的文件夹，ps：不是指redis容器里面的目录哦，而是还是在containers目录进行“cd”命令继续进入占用32G的文件夹内</p><p>进入文件夹之后使用“du -ah”命令查看当前文件夹中的文件磁盘占用大小，从图中咱们可以看出是redis的json日志文件磁盘占用太大，遂把文件进行清除处理先解决占用办法</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">du -ah</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><img src="/img/docker.pdf-14-2.png"><p>咱们使用“cat /dev/null &gt; *-json.log”命令将这个json文件给清理掉，通过下图咱们就能看出来该文件已经清理掉</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">cat /dev/null &gt; *-json.log</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><img src="/img/docker.pdf-14-4.png"><p>当然咯咱们清理了之后还是要重启容器服务哦，虽然这个时候容器还是显示运行，其实已经down了哦</p><p>以上咱们的问题解决了，但是这只是治本不治根，往下看解决根本的方法</p><p>如果说要从根本方法上解决docker容器日志文件磁盘满载的问题，有几种解决方法</p><p>方法一：不推荐，但是最快捷有效，把当前运行的容器直接给停止删掉</p><p>方法二：在docker运行的时候指定日志的最大磁盘容量</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker run ...... --log-opt max-size=10m --log-opt max-file=1</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>方法三：在docker的配置文件中进行全局修改：新建或修改/etc/docker/daemon.json，添加log-dirver和log-opts参数（daemon.json）：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">{</span>
<span class="line">  &quot;log-driver&quot;: &quot;json-file&quot;,</span>
<span class="line">  &quot;log-opts&quot;: {</span>
<span class="line">    &quot;max-size&quot;: &quot;10m&quot;,</span>
<span class="line">    &quot;max-file&quot;: &quot;3&quot;,</span>
<span class="line">    &quot;labels&quot;: &quot;production_status&quot;,</span>
<span class="line">    &quot;env&quot;: &quot;os,customer&quot;</span>
<span class="line">  }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方法四：该方法针对docker-compose的童鞋们，在docker-compose文件中配置日志</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">logging:</span>
<span class="line">  options:</span>
<span class="line">    max-size: &#39;12m&#39;</span>
<span class="line">    max-file: &#39;5&#39;</span>
<span class="line">  driver: json-file</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Docker-V 详解</strong></p><p><strong>笔记本：</strong> docker</p><p><strong>创建时间：</strong> 2023/12/11 15:37 <strong>更新时间：</strong> 2023/12/11 15:38</p><h4 id="docker-v-详解" tabindex="-1"><a class="header-anchor" href="#docker-v-详解"><span><strong>Docker-V 详解</strong></span></a></h4><p><strong>1. 作用</strong></p><p>挂载宿主机的一个目录。</p><p><strong>2. 案例</strong></p><p>譬如我要启动一个centos容器，宿主机的/test目录挂载到容器的/soft目录，可通过以下方式指定：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker run -it -v /test:/soft centos /bin/bash</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>冒号&quot;:&quot;前面的目录是宿主机目录，后面的目录是容器内目录</p><p><strong>3. 注意事项</strong></p><ul><li>3.1 容器目录不可以为相对路径</li><li>3.2宿主机目录如果不存在，则会自动生成</li></ul><p>这样宿主机目录和容器内的目录就互通.可以互相传输文件</p><p><strong>docker如何删除容器里的文件</strong></p><p><strong>笔记本：</strong> docker</p><p><strong>创建时间：</strong> 2023/12/11 15:35 <strong>更新时间：</strong> 2023/12/11 15:36</p><h4 id="docker如何删除容器里的文件" tabindex="-1"><a class="header-anchor" href="#docker如何删除容器里的文件"><span><strong>docker如何删除容器里的文件</strong></span></a></h4><p><strong>问题起因</strong></p><p>为什么会有这个问题呢？</p><p>起因是要从一个es搜索引擎从另一个es搜索引擎中拷贝数据</p><p>图方便没用软件导致重启es的时候拷贝的数据，引发了es的启动异常</p><p><strong>解决方案</strong></p><p>docker inspect</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">   docker inspect 容器 Id</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>先使用docker inspect 查询出容器的所有信息</p><p>然后找到他的Mounts 下的Source，就是容器在宿主机中的位置</p><img src="/img/docker.pdf-17-0.png"><p>我的路径是</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">   cd /home/data/docker/docker/volumes/509ada780c40cd8ea226c5507929e1e5160702733b032495b1776250fb6d3e89/_data</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>进入目录找到要删除的文件</p><img src="/img/docker.pdf-17-1.png"><p>然后 rm 要删除的文件</p><p><strong>Docker Portainer忘记admin登录密码怎么办</strong></p><p><strong>笔记本：</strong> docker</p><p><strong>创建时间：</strong> 2023/12/11 15:32 <strong>更新时间：</strong> 2023/12/11 15:34</p><p><strong><a href="https://www.cnblogs.com/A1999/p/15993682.html" target="_blank" rel="noopener noreferrer">Docker管理工具Portainer忘记admin登录密码怎么办?</a></strong></p><p>Portainer官网解决方法链接</p><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdocs.portainer.io%2Fv%2Fce-2.11%2Fadvanced%2Freset-admin" target="_blank" rel="noopener noreferrer">https://docs.portainer.io/v/ce-2.11/advanced/reset-admin</a></p><p>炒鸡详细步骤！</p><p>1.查看所有容器,包括未运行的</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">  docker ps -a</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>2.找到Portainer对应信息</p><img src="/img/docker.pdf-18-1.png" style="zoom:500%;"><p>3.停止Portainer容器</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker stop portainerid</span>
<span class="line">我这里就应该是</span>
<span class="line">docker stop 507566f7086e</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>4.找到Portainer容器挂载信息</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker inspect portainerid</span>
<span class="line">我这里就应该是</span>
<span class="line">docker inspect 507566f7086e</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>找到这个信息</p><img src="/img/docker.pdf-18-2.png" style="zoom:500%;"><p>5.执行命令重置密码</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker run --rm -v /dockerpath:/data portainer/helper-reset-password</span>
<span class="line">我这里应该是</span>
<span class="line">docker run --rm -v /mnt/docker/portainer:/data portainer/helper-reset-password</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img src="/img/docker.pdf-18-4.png" style="zoom:500%;"><p>现在admin登录的密码就为：4~!15SlshwmY#89FpcRE06u/{HL2(_Z:</p><p>6.启动容器,输入用户名密码就可以登录喽</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker start portainerid</span>
<span class="line">我这里就应该是</span>
<span class="line">docker start 507566f7086e</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>7.修改Portainer登录密码</p><p>左侧菜单-&gt;Users</p><img src="/img/docker.pdf-18-3.png"><p>点击admin,输入新密码更新就OK喽</p><img src="/img/docker.pdf-19-0.png"><p><strong>docker下载镜像卡死或太慢</strong></p><p><strong>笔记本：</strong> docker</p><p><strong>创建时间：</strong> 2023/12/11 15:29 <strong>更新时间：</strong> 2023/12/11 15:30</p><h4 id="docker下载镜像卡死或太慢" tabindex="-1"><a class="header-anchor" href="#docker下载镜像卡死或太慢"><span><strong>docker下载镜像卡死或太慢</strong></span></a></h4><p><strong>docker下载镜像多数为国外资源，很慢，这里百度找到可以使用阿里云加速</strong></p><p><strong>1、找到个人阿里云的镜像加速器（要1.10.0以上版本的docker）</strong></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line"> docker -v 查看 docker 版本</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>2、到阿里云官网找属于自己的加速器地址（不建议照抄我的，每个人都有，免费的）</strong></p><p><a href="https://cr.console.aliyun.com/cn-beijing/instances/mirrors" target="_blank" rel="noopener noreferrer">https://cr.console.aliyun.com/cn-beijing/instances/mirrors</a></p><img src="/img/docker.pdf-20-0.png"><p><strong>3、编辑daemon.json文件添加个人阿里云加速器地址进去</strong></p><p><strong>（如果没有daemon.json文件就用vim编辑创建）sudo 命令是暂时获取管理员权限</strong></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line"> sudo mkdir -p/etc/docker</span>
<span class="line"></span>
<span class="line"> sudo tee /etc/docker/daemon.json &lt;&lt; - &#39;EOF&#39;</span>
<span class="line"></span>
<span class="line"> {</span>
<span class="line"> &quot;registry-mirrors&quot;: [&quot;https://wb640ddh.mirror.aliyuncs.com&quot;]</span>
<span class="line"> }</span>
<span class="line"></span>
<span class="line"> EOF</span>
<span class="line"></span>
<span class="line"> sudo systemctl daemon-reload</span>
<span class="line"> sudo systemctl restart docker</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><a href="https://blog.csdn.net/meltsnow/article/details/92851811" target="_blank" rel="noopener noreferrer">参考：https://blog.csdn.net/meltsnow/article/details/92851811</a></p><p><strong>centos8安装docker</strong></p><p><strong>笔记本：</strong> docker</p><p><strong>创建时间：</strong> 2023/12/11 15:27 <strong>更新时间：</strong> 2023/12/11 15:28</p><h4 id="centos8安装docker" tabindex="-1"><a class="header-anchor" href="#centos8安装docker"><span><strong>centos8安装docker</strong></span></a></h4><p>安装依赖</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line"> yum install - y yum - utils device - mapper - persistent - data lvm2</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>添加 <strong>yum源</strong></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line"> yum - config - manager -- add - repo https ://download.docker.com/linux/ centos / docker - ce . repo</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>centos8默认使用podman代替 <strong>docker</strong></p><p>直接安装docker会出现以下错误</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line"> [ root @localhost ~] # yum install docker-ce</span>
<span class="line"> 上次元数据过期检查： 0:00:13 前，执行于 2021 年 06 月 13 日 星期日 16 时 22 分 32 秒。</span>
<span class="line"></span>
<span class="line"> 错误：</span>
<span class="line"></span>
<span class="line"> 问题 : package docker - ce -3:20.10.7-3. el8 . x86_64 requires containerd . io &gt;= 1.4.1, but none of the providers can</span>
<span class="line"> - package containerd . io -1.4.3-3.1. el8 . x86_64 conflicts with runc provided by runc -1.0.0-70. rc92 . module_el 8.</span>
<span class="line"> - package containerd . io -1.4.3-3.1. el8 . x86_64 obsoletes runc provided by runc -1.0.0-70. rc92 . module_el 8.4.0+</span>
<span class="line"> - package containerd . io -1.4.3-3.2. el8 . x86_64 conflicts with runc provided by runc -1.0.0-70. rc92 . module_el 8.</span>
<span class="line"> - package containerd . io -1.4.3-3.2. el8 . x86_64 obsoletes runc provided by runc -1.0.0-70. rc92 . module_el 8.4.0+</span>
<span class="line"> - package containerd . io -1.4.4-3.1. el8 . x86_64 conflicts with runc provided by runc -1.0.0-70. rc92 . module_el 8.</span>
<span class="line"> - package containerd . io -1.4.4-3.1. el8 . x86_64 obsoletes runc provided by runc -1.0.0-70. rc92 . module_el 8.4.0+</span>
<span class="line"> - package containerd . io -1.4.6-3.1. el8 . x86_64 conflicts with runc provided by runc -1.0.0-70. rc92 . module_el 8.</span>
<span class="line"> - package containerd . io -1.4.6-3.1. el8 . x86_64 obsoletes runc provided by runc -1.0.0-70. rc92 . module_el 8.4.0+</span>
<span class="line"> - problem with installed package buildah -1.19.7-1. module_el 8.4.0+781+ acf4c33b . x86_64</span>
<span class="line"> - package buildah -1.19.7-1. module_el 8.4.0+781+ acf4c33b . x86_64 requires runc &gt;= 1.0.0-26, but none of the pr</span>
<span class="line"> - cannot install the best candidate for the job</span>
<span class="line"> - package runc -1.0.0-56. rc5 . dev . git2abd837 . module_el 8.3.0+569+ 1bada2e4 . x86_64 is filtered out by modular fi</span>
<span class="line"> - package runc -1.0.0-64. rc10 . module_el 8.4.0+522+ 66908d0c . x86_64 is filtered out by modular filtering</span>
<span class="line"> - package runc -1.0.0-65. rc10 . module_el 8.4.0+819+ 4afbd1d6 . x86_64 is filtered out by modular filtering</span>
<span class="line"> - package runc -1.0.0-70. rc92 . module_el 8.4.0+786+ 4668b267 . x86_64 is filtered out by modular filtering</span>
<span class="line"> ( 尝试在命令行中添加 &#39;--allowerasing&#39; 来替换冲突的软件包 或 &#39;--skip-broken&#39; 来跳过无法安装的软件包 或 &#39;--nobest&#39;</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解决办法，命令后追加 –allowerasing</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line"> yum install docker - ce docker - ce - cli containerd . io -- allowerasing</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>或者先卸载podman</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line"> yum erase podman buildah</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>安装docker-ce</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line"> [ root @localhost ~] # yum install docker-ce</span>
<span class="line"></span>
<span class="line"> 安装 :</span>
<span class="line"></span>
<span class="line"> docker - ce x86_64 3:20.10.7-3. el8 docker - ce - stable 27 M</span>
<span class="line"></span>
<span class="line"> 安装依赖关系 :</span>
<span class="line"></span>
<span class="line"> container - selinux noarch 2:2.158.0-1. module_el 8.4.0+781+ acf4c33b</span>
<span class="line"></span>
<span class="line"> appstream 51 k</span>
<span class="line"></span>
<span class="line"> containerd . io x86_64 1.4.6-3.1. el8 docker - ce - stable 34 M</span>
<span class="line"> docker - ce - cli x86_64 1:20.10.7-3. el8 docker - ce - stable 33 M</span>
<span class="line"></span>
<span class="line"> docker - ce - rootless - extras x86_64 20.10.7-3. el8 docker - ce - stable 9.2 M</span>
<span class="line"> docker - scan - plugin x86_64 0.8.0-3. el8 docker - ce - stable 4.2 M</span>
<span class="line"></span>
<span class="line"> fuse - overlayfs x86_64 1.4.0-2. module_el 8.4.0+673+ eabfc99d</span>
<span class="line"> appstream 72 k</span>
<span class="line"></span>
<span class="line"> fuse3 x86_64 3.2.1-12. el8 baseos 50 k</span>
<span class="line"> fuse3 - libs x86_64 3.2.1-12. el8 baseos 94 k</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line"> libcgroup x86_64 0.41-19. el8 baseos 70 k</span>
<span class="line"></span>
<span class="line"> libslirp x86_64 4.3.1-1. module_el 8.4.0+575+ 63b40ad7</span>
<span class="line"> appstream 69 k</span>
<span class="line"></span>
<span class="line"> slirp4netns x86_64 1.1.8-1. module_el 8.4.0+641+ 6116a774</span>
<span class="line"></span>
<span class="line"> appstream 51 k</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动并设置开机自启动</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line"> systemctl start docker</span>
<span class="line"> systemctl enable docker</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>验证安装是否成功</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line"> docker version</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>docker容器拷文件</strong></p><p><strong>笔记本：</strong> docker</p><p><strong>创建时间：</strong> 2023/12/11 15:24 <strong>更新时间：</strong> 2023/12/11 15:25</p><p><strong>docker从容器里面拷文件到宿主机或从宿主机拷文件到docker容器里面</strong></p><p>1、从容器里面拷文件到宿主机？</p><p>答：在宿主机里面执行以下命令</p><p>docker cp 容器名：要拷贝的文件在容器里面的路径 要拷贝到宿主机的相应路径</p><p>示例： 假设容器名为testtomcat,要从容器里面拷贝的文件路为：/usr/local/tomcat/webapps/test/js/test.js, 现</p><p>在要将test.js从容器里面拷到宿主机的/opt路径下面，那么命令应该怎么写呢？</p><p>答案：在宿主机上面执行命令</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker cp </span>
<span class="line">testtomcat：/usr/local/tomcat/webapps/test/js/test.js /opt</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>2、从宿主机拷文件到容器里面</p><p>答：在宿主机里面执行如下命令</p><p>docker cp 要拷贝的文件路径 容器名：要拷贝到容器里面对应的路径</p><p>示例：假设容器名为testtomcat,现在要将宿主机/opt/test.js文件拷贝到容器里面</p><p>的/usr/local/tomcat/webapps/test/js路径下面，那么命令该怎么写呢？</p><p>答案：在宿主机上面执行如下命令</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker cp /opt/test.js </span>
<span class="line">testtomcat ： /usr/local/tomcat/webapps/test/js</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>3、在这里在记录一个问题，怎么看容器名称？</p><p>执行命令：docker ps，出现如图所示，其中NAMES就是容器名了。</p><img src="/img/docker.pdf-21-0.png"><p>4.需要注意的是，不管容器有没有启动，拷贝命令都会生效。</p><p><strong>docker save与export</strong></p><p><strong>笔记本：</strong> docker</p><p><strong>创建时间：</strong> 2023/12/11 15:09 <strong>更新时间：</strong> 2023/12/11 15:22</p><p>docker save与docker export的区别 缘起 docker save和docker export都能导出镜像包，咋看起来区别似乎不大。 本文就针对这个问题，试图搞清楚docker save和docker export的功能是什么？适用于什么应用场景？ 本文的测试的Docker版本如下，不保证所有版本的docker都能重现本文的结果。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">&gt;docker version</span>
<span class="line"></span>
<span class="line"></span>
<span class="line">Client:</span>
<span class="line">Version: 17.07.0-ce-rc1</span>
<span class="line">API version: 1.31</span>
<span class="line">Go version: go1.8.3</span>
<span class="line">Git commit: 8c4be39</span>
<span class="line">Built: Wed Jul 26 05:19:44 2017</span>
<span class="line">OS/Arch: windows/amd64</span>
<span class="line"></span>
<span class="line"></span>
<span class="line">Server:</span>
<span class="line">Version: 17.07.0-ce-rc1</span>
<span class="line">API version: 1.31 (minimum version 1.12)</span>
<span class="line">Go version: go1.8.3</span>
<span class="line">Git commit: 8c4be39</span>
<span class="line">Built: Wed Jul 26 05:25:01 2017</span>
<span class="line">OS/Arch: linux/amd64</span>
<span class="line">Experimental: true</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外我是在Windows on bash里面操作docker，有些命令如ls并不是windows命令，如果想要复现我的试验，请换成相应的windows命令。 docker save docker的命令行接口设计得很优雅，很多命令的帮助直接在后面加--help就可以查看。 docker save的帮助如下：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">&gt;docker save --help</span>
<span class="line"></span>
<span class="line">Usage: docker save [OPTIONS] IMAGE [IMAGE...]</span>
<span class="line"></span>
<span class="line">Save one or more images to a tar archive (streamed to STDOUT by default)</span>
<span class="line"></span>
<span class="line">Options:</span>
<span class="line">--help Print usage</span>
<span class="line">-o, --output string Write to a file, instead of STDOUT</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从命令行帮助可以看出，docker save是用来将一个或多个image打包保存的工具。 例如我们想将镜像库中的postgres和mongo打包，那么可以执行：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker save -o images.tar postgres:9.6 mongo:3.4</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>打包之后的images.tar包含postgres:9.6和mongo:3.4这两个镜像。 虽然命令行参数要求指定image，实际上也可以对container进行打包，例如：</p><p>打包之后的images.tar包含postgres:9.6和mongo:3.4这两个镜像。 虽然命令行参数要求指定image，实际上也可以对container进行打包，例如：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">&gt;docker ps</span>
<span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</span>
<span class="line">3623943d369f postgres:9.6 &quot;docker-entrypoint...&quot; 3 hours ago Up 3 hours 5432/tcp postgres</span>
<span class="line"></span>
<span class="line"></span>
<span class="line">&gt;docker save -o b.tar postgres</span>
<span class="line">&gt;docker save -o c.tar postgres:9.6</span>
<span class="line">&gt;ls -al</span>
<span class="line">-rwxrwxrwx 1 root root 277886464 8月 26 14:40 b.tar</span>
<span class="line">-rwxrwxrwx 1 root root 277886464 8月 26 14:41 c.tar</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过以上命令可以看到，b.tar和c.tar是完全一模一样的。这说明，docker save如果指定的是container，docker save将保存的是容器背后的image。 将打包后的镜像载入进来使用docker load，例如：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker load -i images.tar</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>上述命令将会把postgres:9.6和mongo:3.4载入进来，如果本地镜像库已经存在这两个镜像，将会被覆盖。 docker save的应用场景是，如果你的应用是使用docker-compose.yml编排的多个镜像组合，但你要部署的客户服务器并不能连外网。这时，你可以使用docker save将用到的镜像打个包，然后拷贝到客户服务器上使用docker load载入。 docker export 照例查看下docker export的帮助：</p><p>上述命令将会把postgres:9.6和mongo:3.4载入进来，如果本地镜像库已经存在这两个镜像，将会被覆盖。 docker save的应用场景是，如果你的应用是使用docker-compose.yml编排的多个镜像组合，但你要部署的客户服务器并不能连外网。这时，你可以使用docker save将用到的镜像打个包，然后拷贝到客户服务器上使用docker load载入。 docker export 照例查看下docker export的帮助：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">&gt;docker export --help</span>
<span class="line"></span>
<span class="line"></span>
<span class="line">Usage: docker export [OPTIONS] CONTAINER</span>
<span class="line"></span>
<span class="line"></span>
<span class="line">Export a container&#39;s filesystem as a tar archive</span>
<span class="line"></span>
<span class="line"></span>
<span class="line">Options:</span>
<span class="line">--help Print usage</span>
<span class="line">-o, --output string Write to a file, instead of STDOUT</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从帮助可以看出，docker export是用来将container的文件系统进行打包的。例如：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker export -o postgres-export.tar postgres</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>docker export需要指定container，不能像docker save那样指定image或container都可以。</p><p>将打包的container载入进来使用docker import，例如：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker import postgres-export.tar postgres:latest</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>从上面的命令可以看出，docker import将container导入后会成为一个image，而不是恢复为一个container。 另外一点是，docker import可以指定IMAGE[:TAG]，说明我们可以为镜像指定新名称。如果本地镜像库中已经存在同名的镜像，则原有镜像的名称将会被剥夺，赋给新的镜像。原有镜像将成为孤魂野鬼，只能通过IMAGE ID进行操作。 docker export的应用场景主要用来制作基础镜像，比如你从一个ubuntu镜像启动一个容器，然后安装一些软件和进行一些设置后，使用docker export保存为一个基础镜像。然后，把这个镜像分发给其他人使用，比如作为基础的开发环境。</p><h1 id="docker-save和docker-export的区别" tabindex="-1"><a class="header-anchor" href="#docker-save和docker-export的区别"><span>docker save和docker export的区别</span></a></h1><p>总结一下docker save和docker export的区别：</p><ol><li>docker save保存的是镜像（image），docker export保存的是容器（container）；</li><li>docker load用来载入镜像包，docker import用来载入容器包，但两者都会恢复为镜像；</li><li>docker load不能对载入的镜像重命名，而docker import可以为镜像指定新名称。</li></ol><h2 id="脑洞" tabindex="-1"><a class="header-anchor" href="#脑洞"><span>脑洞</span></a></h2><p>前面所讲的内容都是些基础知识，相信各位读者只要仔细看下官方文档就能知晓。这一节我来讲讲文档上没有的东西。 docker load和docker import都可以将tar包导入为镜像，我不禁脑洞一下，docker load能不能导入docker export的容器包，docker import能不能导入docker save的镜像包呢？ 以下开始试验，准备以下两个文件：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">&gt;ls -al</span>
<span class="line">-rwxrwxrwx 1 root root 271760384 8月 26 12:15 postgres-export.tar</span>
<span class="line">-rwxrwxrwx 1 root root 398292480 8月 26 12:13 postgres-save.tar</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中postgres-export.tar是通过docker export导出的容器包，postgres-save.tar是通过docker save保存的镜像包，两者都是基于postgres:9.6镜像。从文件大小可以直观的发现，postgres-export.tar显然要比postgres-save.tar小100多M。 现在试试docker load容器包postgres-export.tar：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">&gt;docker load -i postgres-export.tar</span>
<span class="line">open /var/lib/docker/tmp/docker-import-082344818/bin/json: no such file or directory</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>显然，docker load不能载入容器包。 那么，反过来，docker import载入镜像包可不可以呢？</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">&gt;docker import postgres-save.tar postgres</span>
<span class="line">sha256:8910feec1ee2fac8c152dbdd0aaab360ba0b833af5c3ad59fcd648b9a24d4838</span>
<span class="line">&gt;docker image ls</span>
<span class="line">REPOSITORY TAG IMAGE ID CREATED SIZE</span>
<span class="line">postgres latest 8910feec1ee2 2 minutes ago 398MB</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>WTF，竟然成功了！！！ 莫慌，再试试启动一个postgres容器：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">&gt;docker run postgres</span>
<span class="line">C:\Program Files\Docker\Docker\resources\bin\docker.exe: Error response from daemon: No command specified.</span>
<span class="line">See &#39;C:\Program Files\Docker\Docker\resources\bin\docker.exe run --help&#39;.</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然能够成功地导入为一个镜像，然而这个镜像并不能使用。 要搞清楚到底是怎么回事，我们先看看镜像包和容器包由什么区别： <img src="/img/docker.pdf-22-0.png"></p><p>从上面可以看出右边的postgres-export.tar的内容是一个linux系统的文件目录，猜测就是一个linux镜像。而postgres-save.tar里面到底是什么内容呢？点开一个文件夹看看： <img src="/img/docker.pdf-23-0.png"></p><p>其实就是一个分层的文件系统。Docker镜像实际上就是由这样的一层层文件进行叠加起来的，上层的文件会覆盖下层的同名文件。如果将postgres-save.tar中的各层文件合并到一起，基本就是postgres-export.tar的内容。由于postgres-save.tar里面的各层文件会存在很多重复的文件，这也解释了为什么postgres-save.tar会比postgres-export.tar大100多M。 docker load必须要载入的是一个分层文件系统，而postgres-export.tar并不具有这样的结构，因此无法载入。 而docker import仅仅是将tar包里面的文件复制进来，所以不管tar包里面的文件结构是怎样的，都可以载入进来，所以能够载入postgres-save.tar。但postgres-save.tar并不是一个有效的操作系统镜像，因此当我试图以改镜像启动容器时，容器并不能启动。 我们再来看看docker import的帮助：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">Usage: docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</span>
<span class="line"></span>
<span class="line"></span>
<span class="line">Import the contents from a tarball to create a filesystem image</span>
<span class="line"></span>
<span class="line"></span>
<span class="line">Options:</span>
<span class="line">-c, --change list Apply Dockerfile instruction to the created image</span>
<span class="line">--help Print usage</span>
<span class="line">-m, --message string Set commit message for imported image</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>似乎和docker commit很像：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">Usage: docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span>
<span class="line"></span>
<span class="line"></span>
<span class="line">Create a new image from a container&#39;s changes</span>
<span class="line"></span>
<span class="line"></span>
<span class="line">Options:</span>
<span class="line">-a, --author string Author (e.g., &quot;John Hannibal Smith</span>
<span class="line">&lt;hannibal@a-team.com&gt;&quot;)</span>
<span class="line">-c, --change list Apply Dockerfile instruction to the created image</span>
<span class="line">--help Print usage</span>
<span class="line">-m, --message string Commit message</span>
<span class="line">-p, --pause Pause container during commit (default true)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>发现docker import和docker commit都有--change和--message选项。我们可以将docker import理解为将外部文件复制进来形成只有一层文件系统的镜像，而docker commit则是将当前的改动提交为一层文件系统，然后叠加到原有镜像之上。 关于docker save和docker export的区别讲得差不多，拜了个拜。</p><p><strong>docker--portainer</strong></p><p><strong>笔记本：</strong> docker</p><p><strong>创建时间：</strong> 2021/9/25 20:11 <strong>更新时间：</strong> 2023/12/11 15:21</p><p><strong>作者：</strong> 彼岸樱速</p><p>查找可安装版本</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker search portainer</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><img src="/img/docker.pdf-30-1.png"><p>选择一个版本安装</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker pull portainer/portainer</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>3、docker启动项目</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker run -d -p 9000:9000 --restart=always --name portainer -v /var/run/docker.sock:/var/run/docker.sock -v /home/docker/data:/data portainer/portainer</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>4、初始化密码</p><p>输入服务器地址+端口9000</p><p>输入密码即完成初始化</p><img src="/img/docker.pdf-30-4.png"><p>然后即可正常使用</p><p>如果需要汉化</p><p>创建目录，并解压文件</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">mkdir -p /data/portainer/data /data/portainer/publiccd cd /data/portainerwget https://[dl.quchao.net/Soft/Portainer-CN.zip](http://dl.quchao.net/Soft/Portainer-CN.zip)unzip Portainer-CN.zip -d public</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>运行Portainer</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker run -d --restart=always --name portainer -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v /data/portainer/data:/data -v /data/portainer/public:/public portainer/portainer</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>Docker 配置容器固定IP</strong></p><p><strong>笔记本：</strong> docker</p><p><strong>创建时间：</strong> 2023/12/11 14:42 <strong>更新时间：</strong> 2023/12/11 15:21</p><p><strong>Docker 配置容器固定IP的方法</strong></p><p><strong>前言</strong></p><p>之前使用pipework 分配静态ip是暂时的,重启之后就会失效,并且使用pipework绑定的ip 物理机,</p><p>虚拟机，docker容器的ip都在同一网段,这在生产环境是很困难的,下面使用docker自带的network</p><p>实现固定ip分配,并且重启不会消失。</p><p><strong>环境介绍</strong></p><img src="/img/docker.pdf-32-0.png"><p><strong>绑定步骤</strong></p><p>先操作192.168.1.105虚拟机</p><p>第一步：创建自定义网络</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker network create --subnet=172.172.0.0/24 docker-br0</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>备注：这里选取了172.172.0.0网段，也可以指定其他任意空闲的网段，docker-br0为自定义网桥的名字，可自己任意取名。</p><p>注意：这里子网掩码要使用255.255.255.0也就是IP后面的那个24,因为后面要使用iptables配置路由表,我之前使用255.255.0.0 无法配置.所以这里配置成24.</p><p>创建网桥之后,使用ifconfig查看 会多出一个网桥,该网桥在docker启动或者重启之后,会自动显示出来。</p><p>永久的,可以使用docker network rm docker-br0 移除网桥。</p><p><img src="/img/docker.pdf-32-2.png">第二步：在你自定义的网段选取任意IP地址作为你要启动容器IP</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker run -i -d --net docker-br0 --ip 172.172.0.10 --name nginx -v /usr/local/software/:/mnt/software/ 3bee3060bfc8 /bin/bash</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>备注：创建容器时,在第一步创建的网段中选取了172.172.0.10作为静态IP地址。并且以docker-br0网桥启动. -v是挂载,表示需要将本地哪个目录挂载到容器中。3bee3060bfc8是镜像ID</p><p>使用docker exec -it nginx /bin/bash 进入已启动的容器,使用 yum install net-tools 下载 iptables然后使用ifconfig查看容器ip</p><img src="/img/docker.pdf-33-1.png"><p>第三步：测试本机和容器是否ping通</p><img src="/img/docker.pdf-33-2.png"><p><strong>跨主机容器互访</strong></p><p>第四步：在192.168.1.106虚拟机上,给容器绑定固定ip, 按照之前 第一步到 第三步.</p><p>第五步：在两个容器中互相访问,发现跨主机容器互访,并不能ping通。</p><img src="/img/docker.pdf-34-0.png"><p>第六步：配置路由表</p><p>#添加路由规则</p><p>ip route add 对方容器所在的ip网段/子网掩码 via 对方虚拟机ip dev 通过哪个网卡通信</p><p>如： ip route add 172.172.1.0/24 via 192.168.1.106 dev eno16777736</p><p>添加完成之后,可以使用 route命令 查看添加之后的规则,也可以使用 ip route del 172.172.1.0/24 移除路由规则</p><p>在192.168.1.105 和 192.168.1.106虚拟机上,分别添加对应的路由规则！</p><p>192.168.1.105： ip route add 172.172.1.0/24 via 192.168.1.106 dev eno16777736</p><p>192.168.1.106： ip route add 172.172.0.0/24 via 192.168.1.105 dev eno16777736</p><p>第七步：在两个容器中互相访问,发现可以实现跨主机容器互相ping通了。</p><img src="/img/docker.pdf-34-1.png"><p><strong>docker服务器、以及容器设置自动启动</strong></p><p><strong>笔记本：</strong> docker</p><p><strong>创建时间：</strong> 2023/12/11 15:19 <strong>更新时间：</strong> 2023/12/11 15:20</p><h3 id="docker-服务器、以及容器设置自动启动" tabindex="-1"><a class="header-anchor" href="#docker-服务器、以及容器设置自动启动"><span>docker 服务器、以及容器设置自动启动</span></a></h3><p><strong>一、</strong> docker <strong>服务设置自动启动</strong></p><p><strong>查看已启动的服务</strong></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">systemctl list-units --type=service</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>查看是否设置开机启动</strong></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">systemctl list-unit-files | grep enable</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>设置开机启动</strong></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">systemctl enable docker.service</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>关闭开机启动</strong></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">systemctl disable docker.service</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>二、</strong> docker <strong>容器设置自动启动</strong></p><p>启动时加--restart=always</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker run -tid --name isaler_v0.0.11 -p 8081:8080 --restart=always -v /alidata/iDocker/run/projectImages/isaler/v0.0.11/log:/usr/local/tomcat/logs isaler_v0.0.11</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">Flag Description</span>
<span class="line">no 不自动重启容器. (默认value)</span>
<span class="line">on-failure 容器发生error而退出(容器退出状态不为0)重启容器unless-stopped 在容器已经stop掉或Docker stoped/restarted的时候才重启容器</span>
<span class="line">always 在容器已经stop掉或Docker stoped/restarted的时候才重启容器</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果已经过运行的项目</p><p>如果已经启动的项目，则使用update更新：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker update --restart=always isaler_v0.0.11</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>Docker容器应用日志查看</strong></p><p><strong>笔记本：</strong> docker</p><p><strong>创建时间：</strong> 2023/12/11 15:16 <strong>更新时间：</strong> 2023/12/11 15:18</p><h4 id="docker容器应用日志查看" tabindex="-1"><a class="header-anchor" href="#docker容器应用日志查看"><span><strong>Docker容器应用日志查看</strong></span></a></h4><p><strong>docker</strong> <strong>attach命令</strong></p><p><code>docker attach [options]</code> <code>容器</code> 会连接到正在运行的容器，然后将容器的标准输入、输出和错误流信息附在本地打印</p><p>命令中 <code>options</code> 的取值有三种： <strong><code>--detach-keys</code></strong> <strong>,</strong> <strong><code>--no-stdin</code></strong> <strong>,</strong> <strong><code>--sig-proxy</code></strong> 。</p><p>该命令只是进入容器终端，不会启动新的进程。</p><p>所以当你同时使用多个窗口进入该容器，所有的窗口都会同步显示。</p><p>如果一个窗口阻塞，那么其他窗口也就无法再进行操作。</p><p>使用 <code>ctrl+c</code> 可以直接断开连接，但是这样会导致容器退出，而且还 <code>stop</code> 了。</p><p>如果想在脱离容器终端时，容器依然运行。就需要使用 <code>--sig-proxy</code> 这个参数。例如：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line"> $ docker attach --sig-proxy=false mytest</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>注意：</strong> 当使用 <code>docker attach</code> 连接到容器的标准输入输出时， <code>docker</code> 使用大约 <code>1MB</code> 的内存缓冲区来最大化应用程序的</p><p>如果此缓冲区填满，那么输出或写入的速度将会受到影响。因此查看应用日志，可以使用 <code>docker logs</code> 命令。</p><p><strong>docker logs命令</strong></p><p><code>docker logs [options]</code> <code>容器</code> 获取容器的日志。</p><table><thead><tr><th>名字</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>–details</td><td></td><td>显示提供给日志的额外细节</td></tr><tr><td>–follow或-f</td><td></td><td>按日志输出</td></tr><tr><td>–since</td><td></td><td>从某个时间开始显示，例如2013-01-02T13:23:37</td></tr><tr><td>–tail</td><td>all</td><td>从日志末尾多少行开始显示</td></tr><tr><td>–timestamps或-t</td><td></td><td>显示时间戳</td></tr><tr><td>–until</td><td></td><td>打印某个时间以前的日志，例如 2013-01-02T13:23:37</td></tr></tbody></table><p>例如打印容器 <code>mytest</code> 应用后10行的内容。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line"> $ docker logs --tail=&quot;10&quot; mytest</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>docker 容器设置自动重启</strong></p><p><strong>笔记本：</strong> docker</p><p><strong>创建时间：</strong> 2023/12/11 15:14 <strong>更新时间：</strong> 2023/12/11 15:15</p><h4 id="docker-容器设置自动重启" tabindex="-1"><a class="header-anchor" href="#docker-容器设置自动重启"><span><strong>docker 容器设置自动重启</strong></span></a></h4><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">  # 已有的容器更新为自动重启</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><img src="/img/docker.pdf-37-0.png"><p><strong>Docker批量删除指定名称的容器镜像</strong></p><p><strong>笔记本：</strong> docker</p><p><strong>创建时间：</strong> 2023/12/11 15:12 <strong>更新时间：</strong> 2023/12/11 15:13</p><h4 id="【docker实战】批量删除指定名称的容器镜像" tabindex="-1"><a class="header-anchor" href="#【docker实战】批量删除指定名称的容器镜像"><span><strong>【Docker实战】批量删除指定名称的容器镜像</strong></span></a></h4><p>【场景】</p><p>在学习 <strong>docker</strong> 的时候，经常会编译docker镜像，很多都是基于上一个Dockerfile修改编译而来，</p><p>因此出现了很多 <code>REPOSITORY</code> 和 <code>TAG</code> 为 <code>none</code> 的镜像。</p><p>每次 <code>docker images</code> 查看镜像，都会列出一长串，有的时候一屏还展示不全，</p><p>所以就想要删除某些镜像。但是一个一个删又很费时，那就只有批量删除了。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line"> $ docker images</span>
<span class="line"></span>
<span class="line"> REPOSITORY TAG IMAGE ID CREATED SIZE</span>
<span class="line"></span>
<span class="line"> golang dev f22e6969a040 15 seconds ago 614MB</span>
<span class="line"></span>
<span class="line"> &lt;none&gt; &lt;none&gt; 4db779627117 46 hours ago 614MB</span>
<span class="line"></span>
<span class="line"> redis latest 6ae3401db8cc 5 days ago 154MB</span>
<span class="line"></span>
<span class="line"> &lt;none&gt; &lt;none&gt; 7f2bafff6c0f 9 days ago 151MB</span>
<span class="line"></span>
<span class="line"> &lt;none&gt; &lt;none&gt; a8f72b3b263d 9 days ago 151MB</span>
<span class="line"></span>
<span class="line"> &lt;none&gt; &lt;none&gt; 92e01ab212ce 13 days ago 263MB</span>
<span class="line"></span>
<span class="line"> &lt;none&gt; &lt;none&gt; abc55744f08a 13 days ago 263MB</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>【实战】</p><p>使用 <code>grep</code> 函数查找出所有包含 <code>none</code> 的镜像，然后使用 <code>awk</code> 函数找出所有的镜像ID，并将它们作为参数，使用 <code>d</code></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line"> # 查询所有匹配上的 docker 镜像 ID</span>
<span class="line"></span>
<span class="line"> $ docker images | grep none | awk &#39;{print $3}&#39;</span>
<span class="line"></span>
<span class="line"> 4db779627117</span>
<span class="line"></span>
<span class="line"> 7f2bafff6c0f</span>
<span class="line"></span>
<span class="line"> a8f72b3b263d</span>
<span class="line"></span>
<span class="line"> 92e01ab212ce</span>
<span class="line"></span>
<span class="line"> abc55744f08a</span>
<span class="line"></span>
<span class="line"> b0b5849d174f</span>
<span class="line"></span>
<span class="line"> 3bddbb428319</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>【使用】</p><p><code>docker images | grep none | awk &#39;{print $3}&#39; | xargs docker rmi</code>, 执行该命令即可批量删除指定容器了。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line"> # docker rmi 删除匹配到的镜像 ID</span>
<span class="line"></span>
<span class="line"> $ docker images | grep none | awk &#39;{print $3}&#39; | xargs docker rmi</span>
<span class="line"></span>
<span class="line"> Deleted: sha256:4db779627117f5cb89b4ed3bac92a24ad708b507fce1ea388bfa4d99d6f0e920</span>
<span class="line"></span>
<span class="line"> Deleted: sha256:d303d0e4b3b49cb877ff345ae408ac2bf6f36247510c8c8c818235c046e3ab95</span>
<span class="line"></span>
<span class="line"> Deleted: sha256:c6b43a612c619c71bfe83f4d65d3b65123fc22b62159175d72bd2d7c3a61e6b9</span>
<span class="line"></span>
<span class="line"> Deleted: sha256:98f6c071ac53971c1ff45bffd07d7cbf4079a69c0d18e1c3309500a456490a6b</span>
<span class="line"></span>
<span class="line"> Deleted: sha256:2ab1af2a5356b9d32f260a0cac4915614afae360010112513435ea91c34d05a6</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Docker中如何删除image</strong></p><p><strong>笔记本：</strong> docker</p><p><strong>创建时间：</strong> 2023/12/11 15:06 <strong>更新时间：</strong> 2023/12/11 15:08</p><h4 id="docker中如何删除image-镜像" tabindex="-1"><a class="header-anchor" href="#docker中如何删除image-镜像"><span><strong>Docker中如何删除image（镜像）</strong></span></a></h4><p>docker中删除images的命令是 <code>docker rmi</code> ，但有时候执行此命令并不能删除images</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line"> [yaxin@ubox ~]$docker images</span>
<span class="line"></span>
<span class="line"> REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE</span>
<span class="line"></span>
<span class="line"> eg_sshd latest ed9c93747fe1 45 hours ago 329.8 MB</span>
<span class="line"></span>
<span class="line"> CentOS65 latest e55a74a32125 2 days ago 360.6 MB</span>
<span class="line"></span>
<span class="line"> [yaxin@ubox ~]$docker rmi ed9c93747fe1</span>
<span class="line"></span>
<span class="line"> Untagged: ed9c93747fe16627be822ad3f7feeb8b4468200e5357877d3046aa83cc44c6af</span>
<span class="line"></span>
<span class="line"> [yaxin@ubox ~]$docker images</span>
<span class="line"></span>
<span class="line"> REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE</span>
<span class="line"></span>
<span class="line"> &lt;none&gt; &lt;none&gt; ed9c93747fe1 45 hours ago 329.8 MB</span>
<span class="line"></span>
<span class="line"> CentOS65 latest e55a74a32125 2 days ago 360.6 MB</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看出，image并没有被删除，只是他的tag被删除了，再次执行 <code>docker rmi IMAGE_ID</code> 只会报错</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line"> [yaxin@ubox ~]$docker rmi ed9c93747fe1</span>
<span class="line"></span>
<span class="line"> Error: image_delete: Conflict, ed9c93747fe1 wasn&#39;t deleted</span>
<span class="line"></span>
<span class="line"> 2014/03/22 15:58:27 Error: failed to remove one or more images</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看docker的帮助会发现有两个与删除有关的命令 <code>rm</code> 和 <code>rmi</code></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">rm Remove one or more containers</span>
<span class="line">rmi Remove one or more images</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这里有两个不同的单词，images和container。其中images很好理解，跟平常使用的虚拟机的镜像一个意思，</p><p>相当于一个模版，而container则是images运行时的的状态。</p><p>docker对于运行过的image都保留一个状态（container），</p><p>可以使用命令 <code>docker ps</code> 来查看正在运行的container，</p><p>对于已经退出的container，则可以使用 <code>docker ps -a</code> 来查看。</p><p>如果你退出了一个container而忘记保存其中的数据，</p><p>你可以使用 <code>docker ps -a</code> 来找到对应的运行过的container使用 <code>docker commit</code> 命令将其保存为image然后运行</p><p>回到之前的问题，由于image被某个container引用（拿来运行），</p><p>如果不将这个引用的container销毁（删除），那image肯定是不能被删除。</p><p>所以想要删除运行过的images必须首先删除它的container。继续来看刚才的例子，</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line"> [yaxin@ubox ~]$docker ps -a</span>
<span class="line"></span>
<span class="line"> CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</span>
<span class="line"></span>
<span class="line"> 117843ade696 ed9c93747fe1 /bin/sh -c /usr/sbin 46 hours ago Up 46 hours 0.0.0.0:49153-&gt;22/tcp test_ss</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看出ed9c93747fe1的image被117843ade696的container使用着，所以必须首先删除该container</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line"> [yaxin@ubox ~]$docker rm 117843ade696</span>
<span class="line"></span>
<span class="line"> Error: container_delete: Impossible to remove a running container, please stop it first</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line"> 2014/03/22 16:36:44 Error: failed to remove one or more containers</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>出现错误，这是因为该container正在运行中(运行 <code>docker ps</code> 查看)，先将其关闭</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">[yaxin@ubox ~]$docker rm 117843ade696</span>
<span class="line"></span>
<span class="line"> 117843ade696</span>
<span class="line"></span>
<span class="line"> [yaxin@ubox ~]$docker rmi ed9c93747fe1</span>
<span class="line"></span>
<span class="line"> Deleted: ed9c93747fe16627be822ad3f7feeb8b4468200e5357877d3046aa83cc44c6af</span>
<span class="line"></span>
<span class="line"> Deleted: c8a0c19429daf73074040a14e527ad5734e70363c644f18c6815388b63eedc9b</span>
<span class="line"></span>
<span class="line"> Deleted: 95dba4c468f0e53e5f1e5d76b8581d6740aab9f59141f783f8e263ccd7cf2a8e</span>
<span class="line"></span>
<span class="line"> Deleted: c25dc743e40af6858c34375d450851bd606a70ace5d04e231a7fcc6d2ea23cc1</span>
<span class="line"></span>
<span class="line"> Deleted: 20562f5714a5ce764845119399ef75e652e23135cd5c54265ff8218b61ccbd33</span>
<span class="line"></span>
<span class="line"> Deleted: c8af1dc23af7a7aea0c25ba9b28bdee68caa8866f056e4f2aa2a5fa1bcb12693</span>
<span class="line"></span>
<span class="line"> Deleted: 38fdb2c5432e08ec6121f8dbb17e1fde17d5db4c1f149a9b702785dbf7b0f3be</span>
<span class="line"></span>
<span class="line"> Deleted: 79ca14274c80ac1df1333b89b2a41c0e0e3b91cd1b267b31bef852ceab3b2044</span>
<span class="line"></span>
<span class="line"> [yaxin@ubox ~]$docker images</span>
<span class="line"></span>
<span class="line"> REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE</span>
<span class="line"></span>
<span class="line"> CentOS65 latest e55a74a32125 2 days ago 360.6 MB</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看出，image已经被删除。</p><p><strong>Docker镜像的导入导出</strong></p><p><strong>笔记本：</strong> docker</p><p><strong>创建时间：</strong> 2023/12/11 15:04 <strong>更新时间：</strong> 2023/12/11 15:05</p><p><strong>Docker镜像的导入导出</strong></p><p>本文介绍Docker镜像的导入导出，用于迁移、备份、升级等场景，准备环境如下：</p><p><strong>CentOS 7.0</strong></p><p><strong>Docker 1.18</strong></p><p><strong>导入导出命令介绍</strong></p><p>涉及的命令有export、import、save、load</p><p><strong>save</strong></p><p>命令</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">   docker save [options] images [images...]</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><img src="/img/docker.pdf-41-0.png"><p>示例</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">   docker save -o nginx.tar nginx:latest</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>或</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">   docker save &gt; nginx.tar nginx:latest</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>其中-o和&gt;表示输出到文件， <code>nginx.tar</code> 为目标文件， <code>nginx:latest</code> 是源镜像名（name:tag）</p><p><strong>load</strong></p><p>命令</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">   docker load [options]</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><img src="/img/docker.pdf-41-1.png"><p>示例</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">   docker load -i nginx.tar</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>或</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">   docker load &lt; nginx.tar</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>其中-i和&lt;表示从文件输入。会成功导入镜像及相关元数据，包括tag信息</p><p><strong>export</strong></p><p>命令</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">   docker export [options] container</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><img src="/img/docker.pdf-42-0.png"><p>示例</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">   docker export -o nginx-test.tar nginx-test</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>其中-o表示输出到文件， <code>nginx-test.tar</code> 为目标文件， <code>nginx-test</code> 是源容器名（name）</p><p><strong>import</strong></p><p>命令</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">   docker import [options] file|URL|- [REPOSITORY[:TAG]]</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><img src="/img/docker.pdf-42-1.png"><p>示例</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">   docker import nginx-test.tar nginx:imp</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>或</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">   cat nginx-test.tar | docker import - nginx:imp</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>区别</strong></p><p>export命令导出的tar文件略小于save命令导出的</p><img src="/img/docker.pdf-42-2.png"><p>export命令是从容器（container）中导出tar文件，而save命令则是从镜像（images）中导出</p><p>基于第二点，export导出的文件再import回去时，无法保留镜像所有历史（即每一层layer信息，不熟悉的可以去看Dockerfile），不能进行回滚操作；而save是依据镜像来的，所以导入时可以完整保留下每一层layer信息。如下图所示，nginx:latest是save导出load导入的，nginx:imp是export导出import导入的。</p><img src="/img/docker.pdf-43-0.png"><p><strong>建议</strong></p><p>可以依据具体使用场景来选择命令</p><ul><li><p>若是只想备份images，使用save、load即可</p></li><li><p>若是在启动容器后，容器内容有变化，需要备份，则使用export、import</p></li></ul><p><strong>Docker 镜像打标签</strong></p><p><strong>笔记本：</strong> docker</p><p><strong>创建时间：</strong> 2023/12/11 15:02 <strong>更新时间：</strong> 2023/12/11 15:03</p><h4 id="docker-镜像打标签" tabindex="-1"><a class="header-anchor" href="#docker-镜像打标签"><span>Docker 镜像打标签</span></a></h4><p>前面一章节中，我们使用 <code>docker build</code> 创建了一个 <code>twle/flask_365_102</code> 的镜像</p><p>但是，我们创建的镜像的标签都是 <code>latest</code></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line"> REPOSITORY TAG IMAGE ID CREATED SIZE</span>
<span class="line"></span>
<span class="line"> twle/flask_365_102 latest 083eecd092af 27 seconds ago 922MB</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们可以将标签设置为 <code>365_102</code> 那该多好</p><p><strong>设置镜像标签</strong></p><p>我们可以使用 <code>docker tag</code> 命令，为镜像添加一个新的标签</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line"> [root@localhost flask_365_102]# docker tag 083eecd092af twle/my-flask:365-102</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>083eecd092af</td><td>镜像 ID</td></tr><tr><td>twle</td><td>用户名称</td></tr><tr><td>my-flask:365-<br>102</td><td>镜像源名<br>(repository<br>name)和新的标<br>签名</td></tr></tbody></table><p>使用 docker images 命令可以看到，ID 为 083eecd092af 的镜像多一个标签</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line"> [root@localhost flask_365_102]# docker images</span>
<span class="line"></span>
<span class="line"> REPOSITORY TAG IMAGE ID CREATED SIZE</span>
<span class="line"></span>
<span class="line"> twle/my-flask 365-102 083eecd092af 13 minutes ago 922MB</span>
<span class="line"></span>
<span class="line"> twle/flask_365_102 latest 083eecd092af 13 minutes ago 922MB</span>
<span class="line"></span>
<span class="line"> twle/py365flask102 latest aaf108c1dbdc 4 hours ago 922MB</span>
<span class="line"></span>
<span class="line"> python 3.6.5 29d2f3226daf 3 weeks ago 912MB</span>
<span class="line"></span>
<span class="line"> nginx latest ae513a47849c 4 weeks ago 109MB</span>
<span class="line"></span>
<span class="line"> ubuntu latest 452a96d81c30 4 weeks ago 79.6MB</span>
<span class="line"></span>
<span class="line"> ubuntu 17.10 e4422b8da209 4 weeks ago 99.2MB</span>
<span class="line"></span>
<span class="line"> hello-world latest e38bc07ac18e 7 weeks ago 1.85kB</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">jcdemo/flaskapp latest 084bae02af1b 4 months ago 98.9MB</span>
<span class="line"></span>
<span class="line">ubuntu 17.04 fe1cc5b91830 5 months ago 95.6MB</span>
<span class="line"></span>
<span class="line">ubuntu 16.10 7d3f705d307c 10 months ago 107MB</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>docker 权限问题 Got permission denied while trying to connect to the Docker daemon</strong><strong>socket at 。。。</strong></p><p><strong>笔记本：</strong> docker</p><p><strong>创建时间：</strong> 2023/12/11 15:00 <strong>更新时间：</strong> 2023/12/11 15:02</p><h4 id="docker-权限问题-got-permission-denied-while-trying-to-connect-to-the-docker-daemon-socket-at-。。。" tabindex="-1"><a class="header-anchor" href="#docker-权限问题-got-permission-denied-while-trying-to-connect-to-the-docker-daemon-socket-at-。。。"><span><strong>docker 权限问题</strong> <strong>Got permission denied while trying to connect to</strong> <strong>the Docker daemon socket at 。。。</strong></span></a></h4><p>在用户权限下 <a href="https://so.csdn.net/so/search?q=docker&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener noreferrer">docker</a> 命令需要 sudo 否则出现以下问题</p><img src="/img/docker.pdf-46-0.png"><p>通过将用户添加到docker用户组可以将sudo去掉，命令如下</p><p>sudo groupadd docker #添加docker用户组</p><p>sudo gpasswd -a $USER docker #将登陆用户加入到docker用户组中</p><p>newgrp docker #更新用户组</p><p>ubuntu18.04在重启后会生效，如果不是特别着急，可以先重启然后再做docker操作。</p><p><strong>构建docker镜像并推送到Harbor仓库</strong></p><p><strong>笔记本：</strong> docker</p><p><strong>创建时间：</strong> 2023/12/11 14:58 <strong>更新时间：</strong> 2023/12/11 15:00</p><h4 id="构建docker镜像并推送到harbor仓库" tabindex="-1"><a class="header-anchor" href="#构建docker镜像并推送到harbor仓库"><span><strong>构建docker镜像并推送到Harbor仓库</strong></span></a></h4><p>拉取tomcat镜像并推到harbor。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line"> docker pull tomcat</span>
<span class="line"></span>
<span class="line"> docker login test.com</span>
<span class="line"></span>
<span class="line"> docker tag tomcat:latest test.com/sunsy/basic-tomcat</span>
<span class="line"></span>
<span class="line"> docker push test.com/sunsy/basic-tomcat</span>
<span class="line"></span>
<span class="line"> #tomcat后面要跟上tag或者image id,如果忘记了,可以使用命令docker images查看</span>
<span class="line"></span>
<span class="line"> #test.com是Harbor仓库地址,sunsy是Harbor仓库下的项目名称</span>
<span class="line"></span>
<span class="line"> #basic-tomcat是推到项目上,该镜像的镜像名</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img src="/img/docker.pdf-47-0.png"><p>1、开始构建镜像</p><p>先要登录到harbor上，才有权限</p><p>docker login test.com</p><img src="/img/docker.pdf-47-1.png"><p>写dockerfile</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line"> FROM docker.io/tomcat:latest</span>
<span class="line"></span>
<span class="line"> MAINTAINER crj</span>
<span class="line"></span>
<span class="line"> RUN rm -rf /usr/local/tomcat/webapps/*</span>
<span class="line"></span>
<span class="line"> ADD target/*.war /usr/local/tomcat/webapps/ROOT.war</span>
<span class="line"> </span>
<span class="line"> docker build -t test.com/sunsy/tomcat-java-demo .</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>6、开始推到harbor上</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker push 192.168.1.25/project/php-demo</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>7、登录harbor 192.168.1.25查看</p><p><strong>docker 镜像仓库Harbor https访问</strong></p><p><strong>笔记本：</strong> docker</p><p><strong>创建时间：</strong> 2023/12/11 14:52 <strong>更新时间：</strong> 2023/12/11 14:57</p><h4 id="docker-镜像仓库harbor-https访问" tabindex="-1"><a class="header-anchor" href="#docker-镜像仓库harbor-https访问"><span><strong>docker 镜像仓库Harbor https访问</strong></span></a></h4><p>配置harbor的https</p><p>为什么要配置https?</p><p>因为后续你将镜像打包好放入到harbor仓库中，若是生产环境的镜像，会包含很多隐私的配置文件（db，redis等），需要用到https进行加密</p><p><a href="https://github.com/goharbor/harbor/blob/master/docs/configure_https.md" target="_blank" rel="noopener noreferrer">参考文档：https://github.com/goharbor/harbor/blob/master/docs/configure_https.md</a></p><p><a href="https://github.com/goharbor/harbor/releases" target="_blank" rel="noopener noreferrer">下载：https://github.com/goharbor/harbor/releases</a></p><img src="/img/docker.pdf-49-0.png"><p>下载：docker-compose</p><pre><code>                     [https://docs.docker.com/compose/install/#install](https://docs.docker.com/compose/install/#install-compose) compose
</code></pre><p><strong>配置如下</strong></p><p>1、在harbor的目录中新建ssl目录，用来存放自签证书</p><p>[root@docker harbor]# mkdir ssl</p><p>2、[root@docker harbor]# cd ssl/</p><p>3、[root@docker ssl]# openssl genrsa -out ca.key 4096</p><p>4、主要是这里的域名test.com 就是待会访问harbor的域名</p><p>[root@docker ssl]# openssl req -x509 -new -nodes -sha512 -days 3650</p><p>-subj “/C=GZ/ST=Guangd/L=Taipei/O=example/OU=Personal/CN=test.com”</p><p>-key ca.key</p><p>-out ca.crt</p><p>5、[root@docker ssl]# openssl genrsa -out test.com.key 4096</p><p>6、[root@docker ssl]# openssl req -sha512 -new</p><p>-subj “/C=GZ/ST=Guangd/L=Taipei/O=example/OU=Personal/CN=test.com”</p><p>-key test.com.key</p><p>-out test.com.csr</p><p>7、[root@docker ssl]# cat &gt; v3.ext &lt;&lt;-EOF</p><p>authorityKeyIdentifier=keyid,issuer</p><p>basicConstraints=CA:FALSE</p><p>keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment</p><p>extendedKeyUsage = serverAuth</p><p>subjectAltName = @alt_names</p><p>[alt_names]</p><p>DNS.1=test.com</p><p>DNS.2=test</p><p>DNS.3=hostname</p><p>EOF</p><p>8、[root@docker ssl]# openssl x509 -req -sha512 -days 3650</p><p>-extfile v3.ext</p><p>-CA ca.crt -CAkey ca.key -CAcreateserial</p><p>-in test.com.csr</p><p>-out test.com.crt</p><img src="/img/docker.pdf-50-0.png"><p>9、修改配置文件</p><p>[root@docker harbor]# vi harbor.cfg</p><p>hostname = test.com #这个就是你访问的地址</p><p>ui_url_protocol = https</p><p>ssl_cert = ./ssl/test.com.crt</p><p>ssl_cert_key = ./ssl/test.com.key</p><p>harbor_admin_password = 123456</p><p>10、重载配置文件</p><p>[root@docker harbor]# ./prepare</p><p><img src="/img/docker.pdf-50-1.png">11、安装，这个过程需要等5分钟</p><p>[root@docker harbor]# ./install.sh</p><img src="/img/docker.pdf-51-0.png"><p>12、结果正常</p><img src="/img/docker.pdf-51-1.png"><p>13、绑定hosts，访问</p><img src="/img/docker.pdf-51-3.png"><img src="/img/docker.pdf-51-2.png"><p>docker拉取镜像验证：</p><p>1、[root@docker ~]# vi /etc/docker/daemon.json</p><p>{“registry-mirrors”: [“  http://f1361db2.m.daocloud.io”],“insecure-registries”:[“  https://test.</p><p>com”,“192.168.1.13”]}</p><img src="/img/docker.pdf-52-0.png"><p>2、绑定hosts</p><img src="/img/docker.pdf-52-1.png"><p>3、重启docker</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">[root@docker ~]# systemctl restart docker</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>4、登录</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">[root@docker ~]# docker login  https://test.com</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><img src="/img/docker.pdf-52-2.png"><p>第二种推荐：</p><p>最简单的方式</p><p>1、[root@docker ~]# mkdir -p /etc/docker/certs.d/test.com</p><p>2、拷贝生成的test.com.crt</p><p>[root@docker ~]# scp 192.168.1.25:/data/harbor/ssl/test.com.crt /etc/docker/certs.d/test.com/</p><p>3、[root@docker ~]# docker login test.com</p><p>4、不需要重启docker就可以</p><img src="/img/docker.pdf-52-3.png"><p><strong>Docker-compose启动报错:Pool overlaps with other one on this address space</strong></p><p><strong>笔记本：</strong> docker</p><p><strong>创建时间：</strong> 2023/12/11 14:45 <strong>更新时间：</strong> 2023/12/11 14:49</p><h4 id="docker-compose-启动报错-pool-overlaps-with-other-one-on-this-address" tabindex="-1"><a class="header-anchor" href="#docker-compose-启动报错-pool-overlaps-with-other-one-on-this-address"><span><strong>Docker-compose</strong> <strong>启动报错:Pool overlaps with other one on this address</strong></span></a></h4><p>该错误的意思是 <strong>docker</strong> 已有一个容器占用了目前docker-compose里的subnet。</p><p>解决方法</p><p>1、修改当前docker-compose里的network配置，换一个subnet</p><p>2.执行命令 <code>docker network prune</code> （原因：即使容器停止/删除，网段依旧会被占用，运行该命令可清除占用子</p><p><strong>docker将镜像导出为tar文件并导入启动容器</strong></p><p><strong>笔记本：</strong> docker</p><p><strong>创建时间：</strong> 2023/12/11 14:47 <strong>更新时间：</strong> 2023/12/11 14:48</p><h4 id="docker将镜像导出为tar文件并导入启动容器" tabindex="-1"><a class="header-anchor" href="#docker将镜像导出为tar文件并导入启动容器"><span><strong>docker将镜像导出为tar文件并导入启动容器</strong></span></a></h4><p><strong>需求</strong> ：在实际使用 <strong>docker</strong> 的过程中，某些机器不能上网，但是又需要某些docker镜像，</p><p>所以我们可以在能上网的机器上将docker镜像pull下来，然后保存为tar文件，这样直接就可以拿去别的机器上使</p><p><strong>保存镜像文件</strong></p><ol><li><p>启动目标镜像并查看，docker ps</p><img src="/img/docker.pdf-54-0.png"></li></ol><p><a href="https://so.csdn.net/so/search?q=axis&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener noreferrer">2. 将digapiss/ axis</a> 镜像下载下来</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line"> docker save -o 镜像名字 .tar digapiss/axis</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><img src="/img/docker.pdf-54-1.png"><p>3.默认保存在当前路径下</p><img src="/img/docker.pdf-54-2.png"><p>这样我们就将镜像保存下来了。</p><p><strong>恢复镜像文件</strong></p><p>我们将保存的镜像文件进行恢复，首先先将我们一开始有的镜像删除，如果是别的机器就不要删除。</p><ol><li>先将运行的容器关闭，然后查看镜像，docker images，接着删除镜像</li></ol><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line"> docker rmi -f 镜像名字</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><img src="/img/docker.pdf-55-0.png"><p>已经删除了</p><img src="/img/docker.pdf-55-1.png"><ol start="2"><li>导入保存的镜像</li></ol><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line"> docker load --input axis1.4.tar</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><img src="/img/docker.pdf-55-2.png"><p>查看是否倒入成功 ，可见已经成功倒入</p><img src="/img/docker.pdf-55-3.png"><ol start="3"><li><p>启动倒入的镜像</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker run -itd 镜像名字</span>
<span class="line">#如果显示未找到镜像则：</span>
<span class="line">docker run -itd 镜像名字:TAG的值</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><img src="/img/docker.pdf-56-0.png"><p>可见，容器已经启动</p><h2 id="docker常用命令" tabindex="-1"><a class="header-anchor" href="#docker常用命令"><span><strong>docker常用命令</strong></span></a></h2><p><strong>笔记本：</strong> docker</p><p><strong>创建时间：</strong> 2021/9/30 23:36 <strong>更新时间：</strong> 2021/9/30 23:40</p><p><strong>作者：</strong> 彼岸樱速</p><p><code>##</code> 查看 <code>docker</code> 容器版本</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker version</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>##</code> 查看 <code>docker</code> 容器信息</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker info</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>##</code> 查看 <code>docker</code> 容器帮助</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker --help</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>提示：对于镜像的操作可使用镜像名、镜像长ID和短ID。</p><p><strong>2.1、镜像查看</strong></p><p><code>##</code> 列出本地 <code>images</code></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker images</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><img src="/img/docker.pdf-57-2.png"><p><code>##</code> 含中间映像层</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker images -a</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>##</code> 只显示镜像 <code>ID</code></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker images -q</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>##</code> 含中间映像层</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker images -qa</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>##</code> 显示镜像摘要信息 <code>(DIGEST</code> 列 <code>)</code></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker images --digests</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><img src="/img/docker.pdf-57-3.png"><p><code>##</code> 显示镜像完整信息</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker images --no-trunc</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>##</code> 显示指定镜像的历史创建；参数： <code>-H</code> 镜像大小和日期，默认为 <code>true</code> ； <code>--no-trunc</code> 显示完整 的提交记录； <code>-q</code> 仅列出提交记录 <code>ID</code></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker history -H redis</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>2.2、镜像搜索</strong></p><p><code>##</code> 搜索仓库 <code>MySQL</code> 镜像</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker search mysql</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>## --filter=stars=600</code> ：只显示 <code>starts&gt;=600</code> 的镜像</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker search --filter=stars=600 mysql</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>## --no-trunc</code> 显示镜像完整 <code>DESCRIPTION</code> 描述</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker search --no-trunc mysql</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>## --automated</code> ：只列出 <code>AUTOMATED=OK</code> 的镜像</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker search --automated mysql</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>2.3、镜像下载</strong></p><p><code>##</code> 下载 <code>Redis</code> 官方最新镜像，相当于： <code>docker pull redis:latest</code></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker pull redis</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>##</code> 下载仓库所有 <code>Redis</code> 镜像</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker pull -a redis</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>##</code> 下载私人仓库镜像</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker pull bitnami/redis</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><img src="/img/docker.pdf-58-0.png"><p><strong>2.4、镜像删除</strong></p><p><code>##</code> 单个镜像删除，相当于： <code>docker rmi redis:latest</code></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker rmi redis</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>##</code> 强制删除 <code>(</code> 针对基于镜像有运行的容器进程 <code>)</code></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker rmi -f redis</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>##</code> 多个镜像删除，不同镜像间以空格间隔</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker rmi -f redis tomcat nginx</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>##</code> 删除本地全部镜像</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker rmi -f $(docker images -q)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>2.5、镜像构建</strong></p><p><code>##</code> （ <code>1</code> ）编写 <code>dockerfile</code></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">cd /docker/dockerfile</span>
<span class="line">vim mycentos</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>##</code> （ <code>2</code> ）构建 <code>docker</code> 镜像</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker build -f /docker/dockerfile/mycentos -t mycentos:1.1</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>3.1、容器启动</strong></p><p>提示：对于容器的操作可使用CONTAINER ID 或 NAMES。</p><p><code>##</code> 新建并启动容器，参数： <code>-i</code> 以交互模式运行容器； <code>-t</code> 为容器重新分配一个伪输入终端； <code>--</code><code>name</code> 为容器指定一个名称</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker run -i -t --name mycentos</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>##</code> 后台启动容器，参数： <code>-d</code> 已守护方式启动容器</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker run -d mycentos</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>注意：此时使用&quot;docker ps -a&quot;会发现容器已经退出。这是docker的机制：要使Docker容器后台运行，就必 须有一个前台进程。解决方案：将你要运行的程序以前台进程的形式运行。</p><p><code>##</code> 启动一个或多个已经被停止的容器</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker start redis</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>##</code> 重启容器</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker restart redis</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>3.2、容器进程</strong></p><p><code>##top</code> 支持 <code>ps</code> 命令参数，格式： <code>docker top [OPTIONS] CONTAINER [ps OPTIONS]##</code> 列 出 <code>redis</code> 容器中运行进程</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker top redis</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>##</code> 查看所有运行容器的进程信息</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">for i in `docker ps |grep Up|awk &#39;{print $1}&#39;`;do echo / &amp;&amp;docker top $i;</span>
<span class="line"></span>
<span class="line">done</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3.3、容器日志</strong></p><p><code>##</code> 查看 <code>redis</code> 容器日志，默认参数</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker logs rabbitmq</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>##</code> 查看 <code>redis</code> 容器日志，参数： <code>-f</code> 跟踪日志输出； <code>-t</code> 显示时间戳； <code>--tail</code> 仅列出最新 <code>N</code> 条容器</p><p>日志；</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker logs -f -t --tail=20 redis</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>##</code> 查看容器 <code>redis</code> 从 <code>2019</code> 年 <code>05</code> 月 <code>21</code> 日后的最新 <code>10</code> 条日志。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker logs --since=&quot;2019-05-21&quot; --tail=10 redis</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>3.4、容器的进入与退出</strong></p><p><code>##</code> 使用 <code>run</code> 方式在创建时进入</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker run -it centos /bin/bash</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>##</code> 关闭容器并退出</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">exit</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>##</code> 仅退出容器，不关闭</p><p>快捷键： <code>Ctrl + P + Q</code><code>##</code> 直接进入 <code>centos</code> 容器启动命令的终端，不会启动新进程，多个 <code>attach</code> 连接共享容器屏幕，参</p><p>数： <code>--sig-proxy=false</code> 确保 <code>CTRL-D</code> 或 <code>CTRL-C</code> 不会关闭容器</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker attach --sig-proxy=false centos</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>##</code> 在 <code>centos</code> 容器中打开新的交互模式终端，可以启动新进程，参数： <code>-i</code> 即使没有附加也保持 <code>STDIN</code> 打开； <code>-t</code> 分配一个伪终端</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker exec -i -t centos /bin/bash</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>##</code> 以交互模式在容器中执行命令，结果返回到当前终端屏幕</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker exec -i -t centos ls -l /tmp</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>##</code> 以分离模式在容器中执行命令，程序后台运行，结果不会反馈到当前终端</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker exec -d centos touch cache.txt</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>3.5、查看容器</strong></p><p><code>##</code> 查看正在运行的容器</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker ps</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>##</code> 查看正在运行的容器的 <code>ID</code></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker ps -q</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>##</code> 查看正在运行 <code>+</code> 历史运行过的容器</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker ps -a</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>##</code> 显示运行容器总文件大小</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker ps -s</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><img src="/img/docker.pdf-60-0.png"><p><code>##</code> 显示最近创建容器</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker ps -l</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>##</code> 显示最近创建的 <code>3</code> 个容器</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker ps -n 3</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>##</code> 不截断输出</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker ps --no-trunc</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><img src="/img/docker.pdf-60-1.png"><p><code>##</code> 获取镜像 <code>redis</code> 的元信息</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker inspect redis</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>##</code> 获取正在运行的容器 <code>redis</code> 的 <code>IP</code></p><p><code>docker inspect --format=&#39;{{range .</code> NetworkSettings.Networks <code>}}{{.IPAddress}}</code></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">{{end}}&#39; redis</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>3.6、容器的停止与删除</strong></p><p><code>##</code> 停止一个运行中的容器</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker stop redis</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>##</code> 杀掉一个运行中的容器</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker kill redis</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>##</code> 删除一个已停止的容器</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker rm redis</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>##</code> 删除一个运行中的容器</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker rm -f redis</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>##</code> 删除多个容器</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker rm -f $(docker ps -a -q)</span>
<span class="line">docker ps -a -q | xargs docker rm</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>## -l</code> 移除容器间的网络连接，连接名为 <code>db</code></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker rm -l db</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>## -v</code> 删除容器，并删除容器挂载的数据卷</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker rm -v redis</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>3.7、生成镜像</strong></p><p><code>##</code> 基于当前 <code>redis</code> 容器创建一个新的镜像；参数： <code>-a</code> 提交的镜像作者； <code>-c</code> 使用 <code>Dockerfile</code> 指令</p><p>来创建镜像； <code>-m :</code> 提交时的说明文字； <code>-p :</code> 在 <code>commit</code> 时，将容器暂停 <code>docker commit -a=&quot;DeepInThought&quot; -m=&quot;my redis&quot; [redis</code> 容器 <code>ID] myredis:v1.1</code></p><p><strong>3.8、容器与主机间的数据拷贝</strong></p><p><code>##</code> 将 <code>rabbitmq</code> 容器中的文件 <code>copy</code> 至本地路径</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker cp rabbitmq:/[container_path] [local_path]</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>##</code> 将主机文件 <code>copy</code> 至 <code>rabbitmq</code> 容器</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker cp [local_path] rabbitmq:/[container_path]/</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>##</code> 将主机文件 <code>copy</code> 至 <code>rabbitmq</code> 容器，目录重命名为 <code>[container_path]</code> （注意与非重命名 <code>copy</code></p><p>的区别）</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker cp [local_path] rabbitmq:/[container_path]</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></div><!--[--><!--]--></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">最近更新：: </span><time class="meta-item-info" datetime="2026-01-08T07:51:18.000Z" data-allow-mismatch>2026/1/8 07:51</time></div><div class="vp-meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: wuyuying@foresee.com.cn">wuyuying</span><!----><!--]--><!--]--></span></div></div></footer><nav class="vp-page-nav" aria-label="page navigation"><a class="route-link auto-link prev" href="/guide/awt.html" aria-label="AWT &amp;&amp; Swing"><!--[--><div class="hint"><span class="arrow left"></span> Prev</div><div class="link"><span class="external-link">AWT &amp;&amp; Swing</span></div><!--]--></a><!----></nav><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script src="/assets/js/runtime~app.0d688386.js" defer></script><script src="/assets/js/80.d657ec11.js" defer></script><script src="/assets/js/app.52dbea86.js" defer></script>
  </body>
</html>
